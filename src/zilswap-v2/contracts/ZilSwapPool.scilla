scilla_version 0

import BoolUtils IntUtils ListUtils NatUtils

library ZilSwapPool

type ReserveData =
| ReserveData of Uint128 Uint128 Uint128 Uint128 (* reserve0, reserve1, vReserve0, vReserve1 *)

let zero_address = 0x0000000000000000000000000000000000000000
let zero_amount = Uint128 0
let zero_block = BNum 0
let minimum_liquidity = Uint128 1000
let bps = Uint128 10000
let half_bps = Uint128 5000
let precision = Uint256 1000000000000000000 (* for decimal calculations (18dp precision) *)
let short_alpha = Uint256 370301795963710 (* 2 * precision / 5401 *)
let long_alpha = Uint256 185168039996296 (* (2 * precision) / 10801 *)

(* constants used for get_fee *)
let zero_u256 = Uint256 0
let one_u256 = Uint256 1
let two_u256 = Uint256 2
let three_u256 = Uint256 3
let four_u256 = Uint256 4
let five_u256 = Uint256 5 
let nine_u256 = Uint256 9
let ten_u256 = Uint256 10
let twenty_u256 = Uint256 20
let twenty_seven_u256 = Uint256 27
let thirty_u256 = Uint256 30
let sixty_u256 = Uint256 60
let one_hundred_u256 = Uint256 100
let one_hundred_twenty_u256 = Uint256 120
let two_hundred_fifty_u256 = Uint256 250
let eight_hundred_thirty_six_u256 = Uint256 836
let nine_hundred_eighty_five_u256 = Uint256 985
let one_thousand_u256 = Uint256 1000
let ten_thousand_u256 = Uint256 10000
let twenty_thousand_u256 = Uint256 20000
let fifty_thousand_u256 = Uint256 50000
let two_hundred_thousand_u256 = Uint256 200000


(* returns True if all items in the list is True *)
let all_true =
  fun (list : List Bool) =>
    let identity = fun (a: Bool) => a in
    let list_forall_bool = @list_forall Bool in
    list_forall_bool identity list

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  let msgs_tmp = one_msg msg2 in
  Cons {Message} msg1 msgs_tmp

let three_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  fun (msg3 : Message) =>
    let msgs_tmp = two_msgs msg2 msg3 in
    Cons {Message} msg1 msgs_tmp

let get_amount_or_zero =
  fun (maybe : Option Uint128) =>
    match maybe with
    | Some amt => amt
    | None => zero_amount
    end

(* gets the virtual reserve if pool is amplified, or the real reserve otherwise *)
let get_reserve =
  fun (is_amp_pool : Bool) =>
  fun (virtual_reserve : Uint128) =>
  fun (real_reserve : Uint128) =>
    match is_amp_pool with
    | True => virtual_reserve
    | False => real_reserve
    end

let min =
  fun (a : Uint128) =>
  fun (b : Uint128) =>
    let a_lt_b = builtin lt a b in
    match a_lt_b with
    | True => a
    | False => b
    end

let max =
  fun (a : Uint128) =>
  fun (b : Uint128) =>
    let a_lt_b = builtin lt a b in
    match a_lt_b with
    | True => b
    | False => a
    end

let grow =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

let shrink =
  fun (var : Int256) =>
    let maybe_small = builtin to_uint128 var in
    match maybe_small with
    | Some small => small
    | None => let one = Uint128 1 in builtin sub zero_amount one (* throw on overflow *)
    end

let reduce =
  fun (var : Uint256) =>
    let maybe_small = builtin to_uint128 var in
    match maybe_small with
    | Some small => small
    | None => let one = Uint128 1 in builtin sub zero_amount one (* throw on overflow *)
    end
    
(* @dev: Returns (x * y) / z in Uint128 *)
let frac =
  fun (x : Uint128) =>
  fun (y : Uint128) =>
  fun (z : Uint128) =>
    let x_u256 = grow x in
    let y_u256 = grow y in
    let z_u256 = grow z in
    let xy_u256 = builtin mul x_u256 y_u256 in
    let ans_u256 = builtin div xy_u256 z_u256 in
    reduce ans_u256

(* @dev: (x * y) / z in Uint256 *)
let frac_u256 =
  fun (x_u256: Uint256) => 
  fun (y_u256: Uint256) => 
  fun (z_u256: Uint256) => 
    let xy_u256 = builtin mul x_u256 y_u256 in
    builtin div xy_u256 z_u256

(* @dev: Converts 2 Uint128 numbers to Uint256 and returns the product in Uint256 *)
let u128_mul_grow =
  fun (x: Uint128) =>
  fun (y: Uint128) =>
    let x_u256 = grow x in
    let y_u256 = grow y in
    builtin mul x_u256 y_u256

(* @dev Returns x*y in precision *)
(* @solidity MathExt.sol: 
  return x.mul(y) / PRECISION;
*)
let mul_in_precision =
  fun (x : Uint256) =>
  fun (y : Uint256) =>
    let xy = builtin mul x y in
    builtin div xy precision

(* @dev: Used in unsafe_pow_in_precision *)
(* @solidity MathExt.sol: 
  zInPrecision = k % 2 != 0 ? xInPrecision : PRECISION; 
*)
let get_z_in_precision = 
  fun (x_in_precision: Uint256) =>
  fun (k: Uint256)=> 
    let remainder = builtin rem k two_u256 in
    let is_zero = builtin eq remainder zero_u256 in
    match is_zero with 
    | True => precision
    | False =>  x_in_precision
    end

let u32_to_nat_or_zero =
  fun (uint: Uint32) =>
    let nat = uint32_to_nat uint in
    match nat with
    | None => Zero (* uint32 always fits in a nat, so shld nvr happen *)
    | Some r => r
    end

(* @dev: Gets z_in_precision from the pair output of unsafe_pow_in_precision *)
(* @param: k (Pair x_in_precision z_in_precision) *)
let get_z_from_unsafe_pow_in_precision =
  fun (pair: Pair Uint256 (Pair Uint256 Uint256)) =>
  match pair with
  | Pair k xz_pair =>
    match xz_pair with
    | Pair x_in_precision z_in_precision => z_in_precision
    end
  end

(* @solidity MathExt.sol:
  zInPrecision = k % 2 != 0 ? xInPrecision : PRECISION;
  for (k /= 2; k != 0; k /= 2) {
      xInPrecision = (xInPrecision * xInPrecision) / PRECISION;
      if (k % 2 != 0) { zInPrecision = (zInPrecision * xInPrecision) / PRECISION; }
  } 
  return zInPrecision;
*)
let unsafe_pow_in_precision = 
  fun (x_in_precision: Uint256) =>
  fun (k: Uint256) =>
    let z_in_precision = get_z_in_precision x_in_precision k in

    let m = Uint32 128 in
    let m_nat = u32_to_nat_or_zero m in (* max no of loops is fixed at 128 times *)

    let xz_pair = Pair {Uint256 Uint256} x_in_precision z_in_precision in
    let init_pair = Pair {Uint256 (Pair Uint256 Uint256)} k xz_pair in

    let foldk = @nat_foldk (Pair Uint256 (Pair Uint256 Uint256)) in (* k (Pair x_in_precision z_in_precision) *)
    let iter =
      fun (n : Pair Uint256 (Pair Uint256 Uint256)) =>
      fun (ignore : Nat) =>
      fun (recurse : (Pair Uint256 (Pair Uint256 Uint256) -> Pair Uint256 (Pair Uint256 Uint256))) =>
        match n with
        | Pair k cur_xz_pair =>
          let is_k_zero = builtin eq k zero_u256 in
          match is_k_zero with
          | True => n
          | False => 
            match cur_xz_pair with
            | Pair x_in_precision z_in_precision =>
              let new_k = builtin div k two_u256 in
              let inter_x_in_precision = builtin mul x_in_precision x_in_precision in
              let new_x_in_precision = builtin div inter_x_in_precision precision in
              let mod = builtin rem new_k two_u256 in
              let is_odd = builtin eq mod one_u256 in
              match is_odd with
              | False =>
                let new_xz_pair = Pair {Uint256 Uint256} new_x_in_precision z_in_precision in
                let new_accum = Pair {Uint256 (Pair Uint256 Uint256)} new_k new_xz_pair in
                recurse new_accum
              | True =>
                let inter_z_in_precision = builtin mul z_in_precision x_in_precision in
                let new_z_in_precision = builtin div inter_z_in_precision precision in

                let new_xz_pair = Pair {Uint256 Uint256} new_x_in_precision new_z_in_precision in
                let new_accum = Pair {Uint256 (Pair Uint256 Uint256)} new_k new_xz_pair in
                recurse new_accum
              end
            end
          end
        end
      in
    foldk iter init_pair m_nat

(* @solidity VolumeTrendRecorder.sol: 
  return ((precision - alpha) * ema + alpha * value) / precision; 
*)
let get_ema =
  fun (ema : Uint256) =>
  fun (alpha : Uint256) =>
  fun (value : Uint128) =>
    let v = grow value in
    let i_a = builtin sub precision alpha in
    let a = builtin mul i_a ema in
    let b = builtin mul alpha v in
    let n = builtin add a b in
    builtin div n precision

(* @dev: Returns r_factor_in_precision in Uint256 from short_ema and long_ema *)
(* @solidity VolumeTrendRecorder.sol: 
  if (_longEMA == 0) { return 0; }
  return (_shortEMA * MathExt.PRECISION) / _longEMA; 
*)
let calculate_r_factor = 
  fun (short_ema : Uint256) =>
  fun (long_ema : Uint256) =>
    let is_zero = builtin eq long_ema zero_u256 in 
    match is_zero with
    | True => zero_u256
    | False =>
      frac_u256 short_ema precision long_ema
    end

(* @dev: Calculates fee in Uint256 from r_factor_in_precision *)
(* @solidity FeeFormula.sol:
  if (rFactorInPrecision >= R0) { return C0; } 
  else if (rFactorInPrecision >= PRECISION) {
    // C1 + A * (r-U)^3 + b * (r -U)
    if (rFactorInPrecision > U) {
      tmp = rFactorInPrecision - U;
      tmp3 = tmp.unsafePowInPrecision(3);
      return (C1.add(A.mulInPrecision(tmp3)).add(B.mulInPrecision(tmp))) / 10000;
    } else {
      tmp = U - rFactorInPrecision;
      tmp3 = tmp.unsafePowInPrecision(3);
      return C1.sub(A.mulInPrecision(tmp3)).sub(B.mulInPrecision(tmp)) / 10000;
    }
  } else {
    // [ C2 + sign(r - G) *  F * (r-G) ^2 / (L + (r-G) ^2) ] / 10000
    tmp = (rFactorInPrecision > G ? (rFactorInPrecision - G) : (G - rFactorInPrecision));
    tmp = tmp.unsafePowInPrecision(2);
    tmp2 = F.mul(tmp).div(tmp.add(L));
    if (rFactorInPrecision > G) { return C2.add(tmp2) / 10000; }
    else { return C2.sub(tmp2) / 10000; }
  }
*)
let get_fee = 
  fun (r_factor_in_precision: Uint256) => 
    let r0 = Uint256 1477405064814996100 in
    let c2 = Uint256 20036905816356657810 in
    let c0 = frac_u256 sixty_u256 precision ten_thousand_u256 in
    let a = frac_u256 twenty_thousand_u256 precision twenty_seven_u256 in
    let b = frac_u256 two_hundred_fifty_u256 precision nine_u256 in
    let c1 = frac_u256 nine_hundred_eighty_five_u256 precision twenty_seven_u256 in
    let u = frac_u256 one_hundred_twenty_u256 precision one_hundred_u256 in
    let g = frac_u256 eight_hundred_thirty_six_u256 precision one_thousand_u256 in
    let f = builtin mul five_u256 precision in
    let l = frac_u256 two_u256 precision ten_thousand_u256 in
    let is_ge_r0 = uint256_ge r_factor_in_precision r0 in
    match is_ge_r0 with 
    | True => c0
    | False => 
      let is_ge_precision = uint256_ge r_factor_in_precision precision in
      match is_ge_precision with
      | True =>
        (* C1 + A * (r-U)^3 + b * (r -U) *)
        let is_gt_u = uint256_gt r_factor_in_precision u in
        match is_gt_u with
        | True =>
          let tmp = builtin sub r_factor_in_precision u in
          let tmp3 = 
            let pair = unsafe_pow_in_precision tmp three_u256 in
            get_z_from_unsafe_pow_in_precision pair
          in
          let a_tmp3 = mul_in_precision a tmp3 in
          let b_tmp = mul_in_precision b tmp in
          let c1_add_a = builtin add c1 a_tmp3 in
          let c1_add_a_add_b = builtin add c1_add_a b_tmp in
          builtin div c1_add_a_add_b ten_thousand_u256
        | False =>
          let tmp = builtin sub u r_factor_in_precision in
          let tmp3 = 
            let pair = unsafe_pow_in_precision tmp three_u256 in
            get_z_from_unsafe_pow_in_precision pair
          in
          let a_tmp3 = mul_in_precision a tmp3 in
          let b_tmp = mul_in_precision b tmp in
          let c1_sub_a = builtin sub c1 a_tmp3 in
          let c1_sub_a_sub_b = builtin sub c1_sub_a b_tmp in
          builtin div c1_sub_a_sub_b ten_thousand_u256
        end
      | False =>
        (* [ C2 + sign(r - G) *  F * (r-G) ^2 / (L + (r-G) ^2) ] / 10000 *)
        let is_gt_g = uint256_gt r_factor_in_precision g in
        let tmp = match is_gt_g with
        | True => 
          let r_sub_g = builtin sub r_factor_in_precision g in
          let pair = unsafe_pow_in_precision r_sub_g two_u256 in
          get_z_from_unsafe_pow_in_precision pair
        | False => 
          let g_sub_r = builtin sub g r_factor_in_precision in
          let pair = unsafe_pow_in_precision g_sub_r two_u256 in 
          get_z_from_unsafe_pow_in_precision pair
        end in
        let tmp_add_l = builtin add tmp l in
        let tmp2 = frac_u256 f tmp tmp_add_l in
        match is_gt_g with 
        | True =>
          let c2_add_tmp2 = builtin add c2 tmp2 in
          builtin div c2_add_tmp2 ten_thousand_u256
        | False =>
          let c2_sub_tmp2 = builtin sub c2 tmp2 in
          builtin div c2_sub_tmp2 ten_thousand_u256
        end
      end
    end

(* @dev: Returns final_fee in Uint256 *)
(* @solidity DMMPool.sol:
  if (_ampBps <= 20000) { return feeInPrecision; } 
  else if (_ampBps <= 50000) { return (feeInPrecision * 20) / 30; }
  else if (_ampBps <= 200000) { return (feeInPrecision * 10) / 30; }
  else { return (feeInPrecision * 4) / 30; }
} *)
let get_final_fee = 
  fun (fee_in_precision : Uint256) =>
  fun (amp_bps : Uint128) =>
    let amp_bps_u256 = grow amp_bps in
    let is_le_twenty_thousand = uint256_le amp_bps_u256 twenty_thousand_u256 in 
    match is_le_twenty_thousand with
    | True => fee_in_precision
    | False =>
      let is_le_fifty_thousand_u256 = uint256_le amp_bps_u256 fifty_thousand_u256 in
      match is_le_fifty_thousand_u256 with 
      | True => 
        frac_u256 fee_in_precision twenty_u256 thirty_u256 
      | False =>
        let is_le_two_hundred_thousand_u256 = uint256_le amp_bps_u256 two_hundred_thousand_u256 in
        match is_le_two_hundred_thousand_u256 with
        | True => 
          frac_u256 fee_in_precision ten_u256 thirty_u256
        | False => 
          frac_u256 fee_in_precision four_u256 thirty_u256
        end
      end
    end
    
    
(* Error events *)
type Error =
| CodeIsSender
| CodeInsufficientFunds
| CodeInsufficientAllowance
| CodeNotFactory
| CodeInsufficientInput
| CodeInsufficientOutput
| CodeInsufficientLiquidity
| CodeInvalidToAddress
| CodeUnsyncedReserves
| CodeInvalidBalance
| CodeInsufficientAmount

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeIsSender              => Int32 -1
      | CodeInsufficientFunds     => Int32 -2
      | CodeInsufficientAllowance => Int32 -3
      | CodeNotFactory            => Int32 -4
      | CodeInsufficientInput     => Int32 -5
      | CodeInsufficientOutput    => Int32 -6
      | CodeInsufficientLiquidity => Int32 -7
      | CodeInvalidToAddress      => Int32 -8
      | CodeUnsyncedReserves      => Int32 -9
      | CodeInvalidBalance        => Int32 -10
      | CodeInsufficientAmount    => Int32 -11
      end
    in
    { _exception : "Error"; code : result_code }

(* Dummy user-defined ADT *)
type Unit =
| Unit

contract ZilSwapPool
(
  init_token0 : ByStr20 with contract
    field total_supply : Uint128,
    field balances: Map ByStr20 Uint128,
    field allowances: Map ByStr20 (Map ByStr20 Uint128)
  end,
  init_token1 : ByStr20 with contract
    field total_supply : Uint128,
    field balances: Map ByStr20 Uint128,
    field allowances: Map ByStr20 (Map ByStr20 Uint128)
  end,
  init_factory : ByStr20 with contract
    field fee_configuration : Pair ByStr20 Uint128
  end,
  init_amp_bps : Uint128,
  (* zrc-2 required vars *)
  contract_owner: ByStr20,
  name : String,
  symbol : String,
  decimals : Uint32,
  init_supply : Uint128
)

with
  let not_identical_address = let eql = builtin eq init_token0 init_token1 in negb eql in
  let not_zero_address = let eql = builtin eq init_token0 zero_address in negb eql in
  let valid_bps = uint128_ge init_amp_bps bps in
  let valid_token_order = let a = builtin to_uint256 init_token0 in let b = builtin to_uint256 init_token1 in builtin lt a b in
  (* validate zrc-2 required vars *)
  let valid_owner = builtin eq init_factory contract_owner in
  let valid_init_supply = builtin eq init_supply zero_amount in
  let valid_decimals = let twelve = Uint32 12 in builtin eq decimals twelve in
  (* @dev: symbol and name is validated by initializer *)

  let l0 = Nil {Bool} in
  let l1 = Cons {Bool} not_identical_address l0 in
  let l2 = Cons {Bool} not_zero_address l1 in
  let l3 = Cons {Bool} valid_bps l2 in
  let l4 = Cons {Bool} valid_token_order l3 in
  let l5 = Cons {Bool} valid_owner l4 in
  let l6 = Cons {Bool} valid_init_supply l5 in
  let l7 = Cons {Bool} valid_decimals l6 in
  all_true l7
=>

(* @dev: to allow reading of these values by other contracts, these vars are not immutable even though
   @dev: they are never changed and cannot be changed. *)
field factory : ByStr20 with contract
  field fee_configuration : Pair ByStr20 Uint128 (* _feeTo, _governanceFeeBps *)
end = init_factory
field token0 : ByStr20 with contract
  field total_supply : Uint128,
  field balances: Map ByStr20 Uint128,
  field allowances: Map ByStr20 (Map ByStr20 Uint128)
end = init_token0
field token1 : ByStr20 with contract
  field total_supply : Uint128,
  field balances: Map ByStr20 Uint128,
  field allowances: Map ByStr20 (Map ByStr20 Uint128)
end = init_token1

field reserve0 : Uint128 = zero_amount
field reserve1 : Uint128 = zero_amount
field amp_bps : Uint128 = init_amp_bps
field r_factor_in_precision : Uint256 = zero_u256

(* @dev: only used when amp factor > 1 *)
field v_reserve0 : Uint128 = zero_amount
field v_reserve1 : Uint128 = zero_amount

field k_last : Uint128 = zero_amount
field current_block_volume : Uint128 = zero_amount
field short_ema : Uint256 = Uint256 0
field long_ema : Uint256 = Uint256 0
field last_trade_block : BNum = zero_block

(* @dev: zrc-2 *)
field total_supply : Uint128 = zero_amount
field balances: Map ByStr20 Uint128 = Emp ByStr20 Uint128
field allowances: Map ByStr20 (Map ByStr20 Uint128) = Emp ByStr20 (Map ByStr20 Uint128)

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(*** zrc-2 ***)

procedure IsNotSender(address: ByStr20)
  is_sender = builtin eq _sender address;
  match is_sender with
  | True =>
    err = CodeIsSender;
    ThrowError err
  | False =>
  end
end

procedure AuthorizedMoveIfSufficientBalance(from: ByStr20, to: ByStr20, amount: Uint128)
  o_from_bal <- balances[from];
  bal = get_amount_or_zero o_from_bal;
  can_do = uint128_le amount bal;
  match can_do with
  | True =>
    (* Subtract amount from from and add it to to address *)
    new_from_bal = builtin sub bal amount;
    balances[from] := new_from_bal;
    (* Adds amount to to address *)
    get_to_bal <- balances[to];
    new_to_bal = match get_to_bal with
    | Some bal => builtin add bal amount
    | None => amount
    end;
    balances[to] := new_to_bal
  | False =>
    (* Balance not sufficient *)
    err = CodeInsufficientFunds;
    ThrowError err
  end
end

procedure AuthorizedMint(recipient: ByStr20, amount: Uint128)
  o_recipient_bal <- balances[recipient];
  bal = get_amount_or_zero o_recipient_bal;
  new_balance = builtin add amount bal;
  balances[recipient] := new_balance;
  current_total_supply <- total_supply;
  new_total_supply = builtin add current_total_supply amount;
  total_supply := new_total_supply;
  e = {_eventname: "Minted"; minter: _sender; recipient: recipient; amount: amount};
  event e
end

procedure AuthorizedBurnIfSufficientBalance(from: ByStr20, amount: Uint128)
  o_get_bal <- balances[from];
  bal = get_amount_or_zero o_get_bal;
  can_burn = uint128_le amount bal;
  match can_burn with
  | True =>
    (* Subtract amount from from *)
    new_balance = builtin sub bal amount;
    balances[from] := new_balance;
    current_total_supply <- total_supply;
    new_total_supply = builtin sub current_total_supply amount;
    total_supply := new_total_supply;
    e = {_eventname: "Burnt"; burner: _sender; burn_account: from; amount: amount};
    event e
  | False =>
    err = CodeInsufficientFunds;
    ThrowError err
  end
end

(*** pool ***)

procedure IsFactory(address: ByStr20)
  f <- factory;
  is_factory = builtin eq f address;
  match is_factory with
  | True =>
  | False =>
    err = CodeNotFactory;
    ThrowError err
  end
end

(* @dev: If fee is on, mint LP tokens equivalent to configured fee of the growth in sqrt(k)*)
(* @solidity DMMPool.sol:
  (address feeTo, uint16 governmentFeeBps) = factory.getFeeConfiguration();
  feeOn = feeTo != address(0);
  _kLast = kLast; // gas savings
  _vReserve0 = isAmpPool ? data.vReserve0 : data.reserve0; // gas savings
  _vReserve1 = isAmpPool ? data.vReserve1 : data.reserve1; // gas savings
  if (feeOn) {
    if (_kLast != 0) {
      _tmp = _kLast * _vReserve0;
      if (_tmp / _vReserve0 == _kLast) {
          collectedFee0 = _vReserve0.sub(MathExt.sqrt(_tmp.div(_vReserve1)));
      } else {
          collectedFee0 = _vReserve0.sub(
              MathExt.sqrt(_kLast.div(_vReserve1).mul(_vReserve0))
          );
      }
      poolValueInToken0 = data.reserve0.add(
          data.reserve1.mul(_vReserve0).div(_vReserve1)
      );
      numerator = totalSupply().mul(collectedFee0).mul(governmentFeeBps);
      denominator = (poolValueInToken0.sub(collectedFee0)).mul(5000);
      liquidity = numerator / denominator;
      if (liquidity > 0) _mint(feeTo, liquidity);
    }
  } else if (_kLast != 0) { 
    kLast = 0; 
  }
*)
procedure MintFee(is_amp_pool: Bool)
  fee_config <- & init_factory.fee_configuration;
  match fee_config with
  | Pair fee_to fee_bps =>
    is_fee_on = let is_zero_addr = builtin eq fee_to zero_address in negb is_zero_addr;
    kl <- k_last;
    v_r0_ <- v_reserve0;
    v_r1_ <- v_reserve1;
    r0_ <- reserve0;
    r1_ <- reserve1;
    r0 = match is_amp_pool with | False => r0_ | True => v_r0_ end;
    r1 = match is_amp_pool with | False => r1_ | True => v_r1_ end;
    r0_u256 = grow r0;
    r1_u256 = grow r1;
    kl_u256 = grow kl;

    match is_fee_on with (* Checks if fee_config is set *)
    | False =>
      is_not_eq_zero = let a = builtin eq kl zero_amount in negb a;
      match is_not_eq_zero with
      | False =>
      | True =>
        k_last := zero_amount
      end
    | True =>
      is_not_eq_zero = let a = builtin eq kl zero_amount in negb a;
      match is_not_eq_zero with
      | False =>
      | True =>
        t_u256 = u128_mul_grow kl r0;
        t_r0_u256 = builtin div t_u256 r0_u256;
        is_eq = builtin eq t_r0_u256 kl_u256;
        collected_fee = match is_eq with (* value is in token 0 *)
        | True =>
          (* _vReserve0.sub(MathExt.sqrt(_tmp.div(_vReserve1))); *)
          let t_r1_u256 = builtin div t_u256 r1_u256 in
          let sqrt_u256 = builtin isqrt t_r1_u256 in
          let sub_u256 = builtin sub r0_u256 sqrt_u256 in
          reduce sub_u256
        | False =>
          (* _vReserve0.sub(MathExt.sqrt(_kLast.div(_vReserve1).mul(_vReserve0))); *)
          let kl_r1 = builtin div kl r1 in
          let kl_r1_r0_u256 = u128_mul_grow kl_r1 r0 in
          let sqrt_u256 = builtin isqrt kl_r1_r0_u256 in
          let sub_u256 = builtin sub r0_u256 sqrt_u256 in
          reduce sub_u256
        end;
        pool_value = let r1_value = frac r1_ r0 r1 in builtin add r0_ r1_value; (* value in token0 *)
        ts <- total_supply;
        liquidity =
          let numerator = let a = builtin mul ts collected_fee in builtin mul a fee_bps in
          let denominator = let a = builtin sub pool_value collected_fee in builtin mul a half_bps in
          builtin div numerator denominator;
        has_fee = uint128_gt liquidity zero_amount;
        match has_fee with 
        | False =>
          t_r1_u256 = builtin div t_u256 r1_u256;
          a_sqrt_u256 = builtin isqrt t_r1_u256;
          a_sub_u256 = builtin sub r0_u256 a_sqrt_u256;
          a_sub_u128 = reduce a_sub_u256;

          kl_r1 = builtin div kl r1;
          kl_r1_r0_u256 = u128_mul_grow kl_r1 r0;
          b_sqrt_u256 = builtin isqrt kl_r1_r0_u256;
          b_sub_u256 = builtin sub r0_u256 b_sqrt_u256;
          b_sub_u128 = reduce b_sub_u256;

          e = {
            _eventname : "NOMINTFEEYALL";
            liquidity: liquidity;
            collected_fee: collected_fee;
            pool_value: pool_value;
            ts: ts;
            is_eq: is_eq;
            r0_u256: r0_u256;
            r1_u256: r1_u256;
            kl: kl;
            t_u256: t_u256;
            t_r1_u256: t_r1_u256;
            a_sqrt_u256: a_sqrt_u256;
            a_sub_u256: a_sub_u256;
            a_sub_u128: a_sub_u128;
            kl_r1: kl_r1;
            kl_r1_r0_u256: kl_r1_r0_u256;
            b_sqrt_u256: b_sqrt_u256;
            b_sub_u256: b_sub_u256;
            b_sub_u128: b_sub_u128
          };
          event e
        | True =>
          e = {_eventname : "MINTFEEYALL"; fee: liquidity};
          event e;
          AuthorizedMint fee_to liquidity
        end
      end
    end
  end
end

(* @dev: Update reserves *)
procedure Update(is_amp_pool: Bool, data: ReserveData)
  match data with
  | ReserveData r0 r1 vr0 vr1 =>
    reserve0 := r0;
    reserve1 := r1;
    match is_amp_pool with
    | False =>
    | True =>
      v_reserve0 := vr0;
      v_reserve1 := vr1
    end
  end;
  e = {_eventname : "Sync"; data: data};
  event e
end

(* @dev: Update last k value *)
procedure UpdateLastK(is_amp_pool: Bool, data: ReserveData)
  match data with
  | ReserveData r0 r1 vr0 vr1 =>
    match is_amp_pool with
    | True =>
      k = builtin mul vr0 vr1;
      k_last := k
    | False =>
      k = builtin mul r0 r1;
      k_last := k
    end
  end
end

(* @dev: Updates current_block_volume, last_trade_block, short_ema, long_ema, r_factor_in_precision *)
(* @solidity VolumeTrendRecorder.sol:
  skipBlock = blockNumber - lastTradeBlock;
  if (skipBlock == 0) {
    currentBlockVolume = safeUint128(uint256(currentBlockVolume).add(value), 
      "volume exceeds valid range");
    return calculateRFactor(uint256(shortEMA), uint256(longEMA));
  }
  _currentBlockVolume = currentBlockVolume;
  _shortEMA = newEMA(shortEMA, SHORT_ALPHA, currentBlockVolume);
  _longEMA = newEMA(longEMA, LONG_ALPHA, currentBlockVolume);
  _shortEMA = _shortEMA.mulInPrecision(
    (PRECISION - SHORT_ALPHA).unsafePowInPrecision(skipBlock - 1));
  _longEMA = _longEMA.mulInPrecision(
    (PRECISION - LONG_ALPHA).unsafePowInPrecision(skipBlock - 1));
  shortEMA = safeUint128(_shortEMA);
  longEMA = safeUint128(_longEMA);
  currentBlockVolume = safeUint128(value);
  lastTradeBlock = safeUint128(blockNumber);
  emit UpdateEMA(_shortEMA, _longEMA, _currentBlockVolume, skipBlock);
  return calculateRFactor(_shortEMA, _longEMA);
*)
procedure RecordVolume(volume: Uint128)
  (* Set r_factor_in_precision to 0 *)
  r_factor_in_precision := zero_u256;

  current_block <- & BLOCKNUMBER;
  last <- last_trade_block;
  is_first_trade = builtin eq last zero_block;
  last_block = match is_first_trade with
  | True => current_block
  | False => last
  end;

  blocks_skipped_int256 = builtin bsub current_block last_block;
  blocks_skipped_u128 = shrink blocks_skipped_int256;
  blocks_skipped_u256 = grow blocks_skipped_u128;
  already_updated = builtin eq blocks_skipped_u256 zero_u256;
  match already_updated with
  | True =>
    v <- current_block_volume;
    new_volume = builtin add volume v;
    current_block_volume := new_volume;
    last_trade_block := last_block;

    old_short_ema <- short_ema;
    old_long_ema <- long_ema;
    r_factor = calculate_r_factor old_short_ema old_long_ema;
    r_factor_in_precision := r_factor
  | False =>
    old_block_volume <- current_block_volume;
    old_short_ema <- short_ema;
    old_long_ema <- long_ema;

    blocks_skipped_minus_one = builtin sub blocks_skipped_u256 one_u256;

    new_short_ema = 
      let s_e = get_ema old_short_ema short_alpha old_block_volume in
      let p_minus_short_alpha = builtin sub precision short_alpha in
      let s_e_ = mul_in_precision s_e p_minus_short_alpha in
      let pair = unsafe_pow_in_precision s_e_ blocks_skipped_minus_one in
      get_z_from_unsafe_pow_in_precision pair;
    short_ema := new_short_ema;

    new_long_ema = 
      let l_e = get_ema old_long_ema long_alpha old_block_volume in
      let p_minus_long_alpha = builtin sub precision long_alpha in
      let l_e_ = mul_in_precision l_e p_minus_long_alpha in
      let pair = unsafe_pow_in_precision l_e_ blocks_skipped_minus_one in
      get_z_from_unsafe_pow_in_precision pair;
    long_ema := new_long_ema;

    r_factor = calculate_r_factor new_short_ema new_long_ema;
    r_factor_in_precision := r_factor;
    current_block_volume := volume;
    last_trade_block := current_block
  end
end

(* @solidity DMMPool.sol:
  volume = beforeReserve0.mul(amount1In).div(beforeReserve1).add(amount0In);
  rFactorInPrecision = recordNewUpdatedVolume(block.number, volume);
  feeInPrecision = getFinalFee(FeeFomula.getFee(rFactorInPrecision), ampBps);
  balance0Adjusted = (afterReserve0.mul(PRECISION).sub(amount0In.mul(feeInPrecision))) / PRECISION;
  balance1Adjusted = afterReserve1.mul(PRECISION).sub(amount1In.mul(feeInPrecision)) / PRECISION;
  require(balance0Adjusted.mul(balance1Adjusted) >= beforeReserve0.mul(beforeReserve1), "DMM: K" );
*)
procedure VerifyBalanceAndUpdateEMA(
  amount0_in: Uint128,
  amount1_in: Uint128,
  before_reserve0: Uint128,
  before_reserve1: Uint128,
  after_reserve0: Uint128,
  after_reserve1: Uint128
)
  volume = let a = frac before_reserve0 amount1_in before_reserve1 in builtin add a amount0_in;
  RecordVolume volume;
  amp <- amp_bps;
  s_e <- short_ema;
  l_e <- long_ema;

  (* r_factor_in_precision is set in RecordVolume procedure *)
  r_factor <- r_factor_in_precision;
  intermediate_fee = get_fee r_factor;
  fee_in_precision = get_final_fee intermediate_fee amp;

  balance_0_adjusted = 
    let after_reserve0_u256 = grow after_reserve0 in 
    let amount0_in_u256 = grow amount0_in in 
    let b0 = builtin mul after_reserve0_u256 precision in 
    let b0_a = builtin mul amount0_in_u256 fee_in_precision in 
    let b0_b = builtin sub b0 b0_a in 
    builtin div b0_b precision;
  
  balance_1_adjusted = 
    let after_reserve1_u256 = grow after_reserve1 in 
    let amount1_in_u256 = grow amount1_in in 
    let b1 = builtin mul after_reserve1_u256 precision in 
    let b1_a = builtin mul amount1_in_u256 fee_in_precision in 
    let b1_b = builtin sub b1 b1_a in 
    builtin div b1_b precision;
  
  before_adjustment = u128_mul_grow before_reserve0 before_reserve1;
  after_adjustment = builtin mul balance_0_adjusted balance_1_adjusted;
  is_ge = uint256_ge after_adjustment before_adjustment;
  match is_ge with
  | True =>
    e = {
      _eventname: "VerifyBalanceAndUpdateEMASuccess"; 
      amount0_in: amount0_in; 
      amount1_in: amount1_in;
      before_reserve0: before_reserve0;
      before_reserve1: before_reserve1;
      after_reserve0: after_reserve0;
      after_reserve1: after_reserve1
    };
    event e
  | False =>
    err = CodeInvalidBalance;
    ThrowError err
  end
end

(***************************************)
(*         ZRC-2 Transitions           *)
(***************************************)

(* @dev: Increase the allowance of an approved_spender over the caller tokens. Only token_owner allowed to invoke.   *)
(* param spender:      Address of the designated approved_spender.                                                   *)
(* param amount:       Number of tokens to be increased as allowance for the approved_spender.                       *)
transition IncreaseAllowance(spender: ByStr20, amount: Uint128)
  IsNotSender spender;
  some_current_allowance <- allowances[_sender][spender];
  current_allowance = get_amount_or_zero some_current_allowance;
  new_allowance = builtin add current_allowance amount;
  allowances[_sender][spender] := new_allowance;
  e = {_eventname : "IncreasedAllowance"; token_owner : _sender; spender: spender; new_allowance : new_allowance};
  event e
end

(* @dev: Decrease the allowance of an approved_spender over the caller tokens. Only token_owner allowed to invoke. *)
(* param spender:      Address of the designated approved_spender.                                                 *)
(* param amount:       Number of tokens to be decreased as allowance for the approved_spender.                     *)
transition DecreaseAllowance(spender: ByStr20, amount: Uint128)
  IsNotSender spender;
  some_current_allowance <- allowances[_sender][spender];
  current_allowance = get_amount_or_zero some_current_allowance;
  new_allowance =
    let amount_le_allowance = uint128_le amount current_allowance in
      match amount_le_allowance with
      | True => builtin sub current_allowance amount
      | False => zero_amount
      end;
  allowances[_sender][spender] := new_allowance;
  e = {_eventname : "DecreasedAllowance"; token_owner : _sender; spender: spender; new_allowance : new_allowance};
  event e
end

(* @dev: Moves an amount tokens from _sender to the recipient. Used by token_owner. *)
(* @dev: Balance of recipient will increase. Balance of _sender will decrease.      *)
(* @param to:  Address of the recipient whose balance is increased.                 *)
(* @param amount:     Amount of tokens to be sent.                                  *)
transition Transfer(to: ByStr20, amount: Uint128)
  AuthorizedMoveIfSufficientBalance _sender to amount;
  e = {_eventname : "TransferSuccess"; sender : _sender; recipient : to; amount : amount};
  event e;
  (* Prevent sending to a contract address that does not support transfers of token *)
  msg_to_recipient = {_tag : "RecipientAcceptTransfer"; _recipient : to; _amount : zero_amount;
                      sender : _sender; recipient : to; amount : amount};
  msg_to_sender = {_tag : "TransferSuccessCallBack"; _recipient : _sender; _amount : zero_amount;
                  sender : _sender; recipient : to; amount : amount};
  msgs = two_msgs msg_to_recipient msg_to_sender;
  send msgs
end

(* @dev: Move a given amount of tokens from one address to another using the allowance mechanism. The caller must be an approved_spender. *)
(* @dev: Balance of recipient will increase. Balance of token_owner will decrease.                                                        *)
(* @param from:    Address of the token_owner whose balance is decreased.                                                                 *)
(* @param to:      Address of the recipient whose balance is increased.                                                                   *)
(* @param amount:  Amount of tokens to be transferred.                                                                                    *)
transition TransferFrom(from: ByStr20, to: ByStr20, amount: Uint128)
  o_spender_allowed <- allowances[from][_sender];
  allowed = get_amount_or_zero o_spender_allowed;
  can_do = uint128_le amount allowed;
  match can_do with
  | True =>
    AuthorizedMoveIfSufficientBalance from to amount;
    e = {_eventname : "TransferFromSuccess"; initiator : _sender; sender : from; recipient : to; amount : amount};
    event e;
    new_allowed = builtin sub allowed amount;
    allowances[from][_sender] := new_allowed;
    (* Prevent sending to a contract address that does not support transfers of token *)
    msg_to_recipient = {_tag: "RecipientAcceptTransferFrom"; _recipient : to; _amount: zero_amount;
                        initiator: _sender; sender : from; recipient: to; amount: amount};
    msg_to_sender = {_tag: "TransferFromSuccessCallBack"; _recipient: _sender; _amount: zero_amount;
                    initiator: _sender; sender: from; recipient: to; amount: amount};
    msgs = two_msgs msg_to_recipient msg_to_sender;
    send msgs
  | False =>
    err = CodeInsufficientAllowance;
    ThrowError err
  end
end

(*************************************)
(*             Callbacks             *)
(*************************************)

(* @dev: Handle callback when sending ZRC-2 tokens to the recipient using Transfer transition *)
transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end

(* @dev: Handle callback when sending ZRC-2 tokens to the recipient using TransferFrom transition *)
transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end

(* @dev: Handle callback when sending ZRC-2 tokens to the recipient using Transfer transition *)
transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end

(***************************************)
(*          Pool Transitions           *)
(***************************************)

(* @dev This low-level function should be called from a contract
   which performs important safety checks *)
(* @solidity DMMPool.sol:
  (bool isAmpPool, ReserveData memory data) = getReservesData();
  ReserveData memory _data;
  _data.reserve0 = token0.balanceOf(address(this));
  _data.reserve1 = token1.balanceOf(address(this));
  amount0 = _data.reserve0.sub(data.reserve0);
  amount1 = _data.reserve1.sub(data.reserve1);
  bool feeOn = _mintFee(isAmpPool, data);
  _totalSupply = totalSupply();
  if (_totalSupply == 0) {
    if (isAmpPool) {
      _ampBps = ampBps;
      _data.vReserve0 = _data.reserve0.mul(_ampBps) / BPS;
      _data.vReserve1 = _data.reserve1.mul(_ampBps) / BPS;
    }
    liquidity = MathExt.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
    _mint(address(-1), MINIMUM_LIQUIDITY);
  } else {
    liquidity = Math.min(amount0.mul(_totalSupply) / data.reserve0,amount1.mul(_totalSupply) / data.reserve1);
    if (isAmpPool) {
      b = liquidity.add(_totalSupply);
      _data.vReserve0 = Math.max(data.vReserve0.mul(b) / _totalSupply, _data.reserve0);
      _data.vReserve1 = Math.max(data.vReserve1.mul(b) / _totalSupply, _data.reserve1);
    }
  }
  require(liquidity > 0, "DMM: INSUFFICIENT_LIQUIDITY_MINTED");
  _mint(to, liquidity);
  _update(isAmpPool, _data);
  if (feeOn) kLast = getK(isAmpPool, _data);
  emit Mint(msg.sender, amount0, amount1);
*)
transition Mint(to : ByStr20)
  amp <- amp_bps;
  is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;

  r0 <- reserve0;
  r1 <- reserve1;
  vr0 <- v_reserve0;
  vr1 <- v_reserve1;

  m_r0 <- & init_token0.balances[_this_address];
  new_r0 = get_amount_or_zero m_r0;
  m_r1 <- & init_token1.balances[_this_address];
  new_r1 = get_amount_or_zero m_r1;

  (* Amount of zrc2 tokens transferred to pool by liquidity provider *)
  amount0 = builtin sub new_r0 r0;
  amount1 = builtin sub new_r1 r1;

  MintFee is_amp_pool;

  supply <- total_supply;
  is_zero = builtin eq supply zero_amount;
  result = match is_zero with
  | True =>
    (* new pool *)
    let data = match is_amp_pool with
    | False =>
      ReserveData new_r0 new_r1 zero_amount zero_amount
    | True =>
      let v_r0 = let n0 = builtin mul new_r0 amp in builtin div n0 bps in
      let v_r1 = let n1 = builtin mul new_r1 amp in builtin div n1 bps in
      ReserveData new_r0 new_r1 v_r0 v_r1
    end in
    let liquidity = let x = builtin mul amount0 amount1 in let y = builtin isqrt x in builtin sub y minimum_liquidity in
    Pair {Uint128 ReserveData} liquidity data
  | False =>
    (* existing pool *)
    let liquidity =
      let a = frac amount0 supply r0 in
      let b = frac amount1 supply r1 in
      min a b
    in
    let data = match is_amp_pool with
    | False =>
      ReserveData new_r0 new_r1 zero_amount zero_amount
    | True =>
      let ls = builtin add liquidity supply in
      let v_r0 = let n0 = frac vr0 ls supply in max n0 new_r0 in
      let v_r1 = let n1 = frac vr1 ls supply in max n1 new_r1 in
      ReserveData new_r0 new_r1 v_r0 v_r1
    end in
    Pair {Uint128 ReserveData} liquidity data
  end;

  match is_zero with
  | False => | True =>
    (* permanently lock the first minimum_liquidity tokens *)
    AuthorizedMint zero_address minimum_liquidity
  end;

  match result with
  | Pair liquidity data =>
    mint_failed = builtin eq liquidity zero_amount;
    match mint_failed with
    | False => | True =>
      err = CodeInsufficientLiquidity;
      ThrowError err
    end;

    AuthorizedMint to liquidity;
    Update is_amp_pool data;
    UpdateLastK is_amp_pool data;

    e = {_eventname: "PoolMinted"; minter: _sender; amount0: amount0; amount1: amount1};
    event e
  end
end

(* @dev This low-level function should be called from a contract
   which performs important safety checks.
   User must transfer LP token to this contract before call burn *)
(* @solidity DMMPool.sol:
  (bool isAmpPool, ReserveData memory data) = getReservesData();
  IERC20 _token0 = token0;
  IERC20 _token1 = token1;

  balance0 = _token0.balanceOf(address(this));
  balance1 = _token1.balanceOf(address(this));
  require(balance0 >= data.reserve0 && balance1 >= data.reserve1, "DMM: UNSYNC_RESERVES");
  liquidity = balanceOf(address(this));

  bool feeOn = _mintFee(isAmpPool, data);
  _totalSupply = totalSupply();
  amount0 = liquidity.mul(balance0) / _totalSupply;
  amount1 = liquidity.mul(balance1) / _totalSupply;
  require(amount0 > 0 && amount1 > 0, "DMM: INSUFFICIENT_LIQUIDITY_BURNED");
  _burn(address(this), liquidity);
  _token0.safeTransfer(to, amount0);
  _token1.safeTransfer(to, amount1);
  ReserveData memory _data;
  _data.reserve0 = _token0.balanceOf(address(this));
  _data.reserve1 = _token1.balanceOf(address(this));
  if (isAmpPool) {
    b = Math.min(
      _data.reserve0.mul(_totalSupply) / data.reserve0,
      _data.reserve1.mul(_totalSupply) / data.reserve1
    );
    _data.vReserve0 = Math.max(data.vReserve0.mul(b) / _totalSupply, _data.reserve0);
    _data.vReserve1 = Math.max(data.vReserve1.mul(b) / _totalSupply, _data.reserve1);
  }
  _update(isAmpPool, _data);
  if (feeOn) kLast = getK(isAmpPool, _data); // data are up-to-date
  emit Burn(msg.sender, amount0, amount1, to);
*)
transition Burn()
  amp <- amp_bps;
  is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;

  r0 <- reserve0;
  r1 <- reserve1;
  v_r0 <- v_reserve0;
  v_r1 <- v_reserve1;

  m_b0 <- & init_token0.balances[_this_address];
  balance0 = get_amount_or_zero m_b0;
  m_b1 <- & init_token1.balances[_this_address];
  balance1 = get_amount_or_zero m_b1;

  is_reserves_synced =
    let b0_ok = uint128_ge balance0 r0 in
    let b1_ok = uint128_ge balance1 r1 in
    andb b0_ok b1_ok;
  match is_reserves_synced with
  | True =>
  | False =>
    err = CodeUnsyncedReserves;
    ThrowError err
  end;

  MintFee is_amp_pool;

  supply <- total_supply;
  m_l <- balances[_this_address];
  liquidity = get_amount_or_zero m_l;

  (* Amount of tokens to transfer to liquidity provider *)
  amount0 = frac liquidity balance0 supply;
  amount1 = frac liquidity balance1 supply;

  is_sufficient_liquidity_burnt =
    let a0_ok = uint128_gt amount0 zero_amount in
    let a1_ok = uint128_gt amount1 zero_amount in
    andb a0_ok a1_ok;
  match is_sufficient_liquidity_burnt with
  | True =>
  | False =>
    err = CodeInsufficientLiquidity;
    ThrowError err
  end;

  AuthorizedBurnIfSufficientBalance _this_address liquidity;

  msg_to_token0 = {
    _tag: "Transfer"; _recipient: init_token0; _amount: zero_amount;
    to: _origin; amount: amount0
  };

  msg_to_token1 = {
    _tag: "Transfer"; _recipient: init_token1; _amount: zero_amount;
    to: _origin; amount: amount1
  };

  msgs = two_msgs msg_to_token0 msg_to_token1;
  send msgs;

  new_r0 = builtin sub balance0 amount0;
  new_r1 = builtin sub balance1 amount1;

  data = match is_amp_pool with
  | True =>
    let x = frac new_r0 supply r0 in
    let y = frac new_r1 supply r1 in
    let b = min x y in
    let vx = frac v_r0 b supply in
    let vy = frac v_r1 b supply in
    let v_r0 = max vx new_r0 in
    let v_r1 = max vy new_r1 in
    ReserveData new_r0 new_r1 v_r0 v_r1
  | False =>
    ReserveData new_r0 new_r1 zero_amount zero_amount
  end;

  Update is_amp_pool data;
  UpdateLastK is_amp_pool data;

  e = {_eventname: "PoolBurnt"; burner: _sender; amount0: amount0; amount1: amount1};
  event e
end

(* @dev This low-level function should be called from a contract
   which performs important safety checks *)
(* @solidity DMMPool.sol:
  require(amount0Out > 0 || amount1Out > 0, "DMM: INSUFFICIENT_OUTPUT_AMOUNT");
  (bool isAmpPool, ReserveData memory data) = getReservesData(); // gas savings
  require(amount0Out < data.reserve0 && amount1Out < data.reserve1, "DMM: INSUFFICIENT_LIQUIDITY");
  ReserveData memory newData;
  {
    IERC20 _token0 = token0;
    IERC20 _token1 = token1;
    require(to != address(_token0) && to != address(_token1), "DMM: INVALID_TO");
    if (amount0Out > 0) _token0.safeTransfer(to, amount0Out); // optimistically transfer tokens
    if (amount1Out > 0) _token1.safeTransfer(to, amount1Out); // optimistically transfer tokens
    if (callbackData.length > 0)
      IDMMCallee(to).dmmSwapCall(msg.sender, amount0Out, amount1Out, callbackData);
    newData.reserve0 = _token0.balanceOf(address(this));
    newData.reserve1 = _token1.balanceOf(address(this));
    if (isAmpPool) {
      newData.vReserve0 = data.vReserve0.add(newData.reserve0).sub(data.reserve0);
      newData.vReserve1 = data.vReserve1.add(newData.reserve1).sub(data.reserve1);
    }
  }
  uint256 amount0In = newData.reserve0 > data.reserve0 - amount0Out
      ? newData.reserve0 - (data.reserve0 - amount0Out)
      : 0;
  uint256 amount1In = newData.reserve1 > data.reserve1 - amount1Out
      ? newData.reserve1 - (data.reserve1 - amount1Out)
      : 0;
  require(amount0In > 0 || amount1In > 0, "DMM: INSUFFICIENT_INPUT_AMOUNT");
  uint256 feeInPrecision = verifyBalanceAndUpdateEma(
      amount0In,
      amount1In,
      isAmpPool ? data.vReserve0 : data.reserve0,
      isAmpPool ? data.vReserve1 : data.reserve1,
      isAmpPool ? newData.vReserve0 : newData.reserve0,
      isAmpPool ? newData.vReserve1 : newData.reserve1
  )
  _update(isAmpPool, newData);
  emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to, feeInPrecision);
*)
transition Swap(
  amount0_out: Uint128,
  amount1_out: Uint128,
  to: ByStr20
)
  is_sending_t0 = uint128_gt amount0_out zero_amount;
  is_sending_t1 = uint128_gt amount1_out zero_amount;

  match is_sending_t0 with 
  | True => | False =>
    match is_sending_t1 with 
    | True => | False =>
      err = CodeInsufficientOutput;
      ThrowError err
    end
  end;

  amp <- amp_bps;
  is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;

  supply <- total_supply;
  r0 <- reserve0;
  r1 <- reserve1;
  v_r0 <- v_reserve0;
  v_r1 <- v_reserve1;

  is_sufficient_liquidity =
    let a0_ok = builtin lt amount0_out r0 in
    let a1_ok = builtin lt amount1_out r1 in
    andb a0_ok a1_ok;
  match is_sufficient_liquidity with
  | True =>
  | False =>
    err = CodeInsufficientLiquidity;
    ThrowError err
  end;

  is_valid_to =
    let t0_ok = let e0 = builtin eq init_token0 to in negb e0 in
    let t1_ok = let e1 = builtin eq init_token1 to in negb e1 in
    andb t0_ok t1_ok;
  match is_valid_to with
  | True =>
  | False =>
    err = CodeInvalidToAddress;
    ThrowError err
  end;

  match is_sending_t0 with
  | False =>
  | True =>
    msg_to_token0 = {
      _tag: "Transfer"; _recipient: init_token0; _amount: zero_amount;
      to: to; amount: amount0_out
    };
    msgs = one_msg msg_to_token0;
    send msgs
  end;

  match is_sending_t1 with
  | False =>
  | True =>
    msg_to_token1 = {
      _tag: "Transfer"; _recipient: init_token1; _amount: zero_amount;
      to: to; amount: amount1_out
    };
    msgs = one_msg msg_to_token1;
    send msgs
  end;

  (* Pool's new token balances after user transfers token_in to the pool *)
  m_b0 <- & init_token0.balances[_this_address];
  b0 = get_amount_or_zero m_b0;
  m_b1 <- & init_token1.balances[_this_address];
  b1 = get_amount_or_zero m_b1;
  
  (* Pool's new reserves after Swap transition is completed *)
  new_r0 = builtin sub b0 amount0_out;
  new_r1 = builtin sub b1 amount1_out;

  new_data = match is_amp_pool with
  | True =>
    let new_vr0 = let a = builtin add v_r0 new_r0 in builtin sub a r0 in
    let new_vr1 = let b = builtin add v_r1 new_r1 in builtin sub b r1 in
    ReserveData new_r0 new_r1 new_vr0 new_vr1
  | False =>
    ReserveData new_r0 new_r1 zero_amount zero_amount
  end;

  amount0_in =
    let r0_sub_amount0_out = builtin sub r0 amount0_out in
    let has_input = uint128_gt new_r0 r0_sub_amount0_out in
    match has_input with
    | False => zero_amount
    | True => builtin sub new_r0 r0_sub_amount0_out
    end;

  amount1_in =
    let r1_sub_amount1_out = builtin sub r1 amount1_out in
    let has_input = uint128_gt new_r1 r1_sub_amount1_out in
    match has_input with
    | False => zero_amount
    | True => builtin sub new_r1 r1_sub_amount1_out
    end;
  
  a0_ok = uint128_gt amount0_in zero_amount;
  a1_ok = uint128_gt amount1_in zero_amount;
  match a0_ok with 
  | True => | False =>
    match a1_ok with 
    | True => | False =>
      err = CodeInsufficientInput;
      ThrowError err
    end
  end;

  match new_data with
  | ReserveData new_r0 new_r1 new_v_r0 new_v_r1 =>
    before_r0 = get_reserve is_amp_pool v_r0 r0;
    before_r1 = get_reserve is_amp_pool v_r1 r1;
    after_r0 = get_reserve is_amp_pool new_v_r0 new_r0;
    after_r1 = get_reserve is_amp_pool new_v_r1 new_r1;

    VerifyBalanceAndUpdateEMA
      amount0_in
      amount1_in
      before_r0
      before_r1
      after_r0
      after_r1
  end;

  Update is_amp_pool new_data;

  e = {
    _eventname: "PoolSwapped"; origin: _origin; sender: _sender;
    amount0_in: amount0_in; amount1_in: amount1_in;
    amount0_out: amount0_out; amount1_out: amount1_out;
    to: to
  };
  event e
end

(* @dev: Transfer tokens such that balances match reserves *)
(* @solidity DMMPool.sol:
  token0.safeTransfer(to, token0.balanceOf(address(this)).sub(reserve0));
  token1.safeTransfer(to, token1.balanceOf(address(this)).sub(reserve1));
*)
transition Skim(to: ByStr20)
  r_0 <- reserve0;
  r_1 <- reserve1;
  m_b0 <- & init_token0.balances[_this_address];
  balance0 = get_amount_or_zero m_b0;
  m_b1 <- & init_token1.balances[_this_address];
  balance1 = get_amount_or_zero m_b1;

  amount0 = builtin sub balance0 r_0;
  amount1 = builtin sub balance1 r_1;

  msg_to_token0  = {
    _tag: "Transfer"; _recipient: init_token0; _amount: zero_amount;
    to: to; amount: amount0
  };

  msg_to_token1  = {
    _tag: "Transfer"; _recipient: init_token1; _amount: zero_amount;
    to: to; amount: amount1
  };

  msgs = two_msgs msg_to_token0 msg_to_token1;
  send msgs;

  e = {_eventname: "Skim"; to: to; amount0: amount0; amount1: amount1};
  event e
end

(* @dev: Force reserves to match balances *)
(* @solidity DMMPool.sol:
  (bool isAmpPool, ReserveData memory data) = getReservesData();
  bool feeOn = _mintFee(isAmpPool, data);
  ReserveData memory newData;
  newData.reserve0 = IERC20(token0).balanceOf(address(this));
  newData.reserve1 = IERC20(token1).balanceOf(address(this));
  // update virtual reserves if this is amp pool
  if (isAmpPool) {
    uint256 _totalSupply = totalSupply();
    uint256 b = Math.min(
        newData.reserve0.mul(_totalSupply) / data.reserve0,
        newData.reserve1.mul(_totalSupply) / data.reserve1
    );
    newData.vReserve0 = Math.max(data.vReserve0.mul(b) / _totalSupply, newData.reserve0);
    newData.vReserve1 = Math.max(data.vReserve1.mul(b) / _totalSupply, newData.reserve1);
  }
  _update(isAmpPool, newData);
  if (feeOn) kLast = getK(isAmpPool, newData); 
*)
transition Sync()
  r0 <- reserve0;
  r1 <- reserve1;
  vr0 <- v_reserve0;
  vr1 <- v_reserve1;

  m_b0 <- & init_token0.balances[_this_address];
  balance0 = get_amount_or_zero m_b0;
  m_b1 <- & init_token1.balances[_this_address];
  balance1 = get_amount_or_zero m_b1;

  new_r0 = balance0;
  new_r1 = balance1;

  amp <- amp_bps;
  is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;
  MintFee is_amp_pool;

  supply <- total_supply;

  data = match is_amp_pool with 
  | False =>
    ReserveData new_r0 new_r1 zero_amount zero_amount
  | True =>
    let b = 
      let c = frac new_r0 supply r0 in 
      let d = frac new_r1 supply r1 in
      min c d in
    let new_vr0 = 
      let x = frac vr0 b supply in 
      max x new_r0 in
    let new_vr1 = 
      let y = frac vr1 b supply in 
      max y new_r1 in
    ReserveData new_r0 new_r1 new_vr0 new_vr1
  end;

  Update is_amp_pool data;

  fee_config <- & init_factory.fee_configuration;
  match fee_config with
  | Pair fee_to fee_bps =>
    is_fee_on = let is_zero_addr = builtin eq fee_to zero_address in negb is_zero_addr;
    match is_fee_on with
    | False =>
    | True =>
      UpdateLastK is_amp_pool data
    end
  end;

  e = {_eventname: "Sync"; data: data};
  event e
end
