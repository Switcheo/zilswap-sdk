scilla_version 0

import BoolUtils IntUtils ListUtils PairUtils NatUtils
library ZilSwapRouter

type ReserveData =
| ReserveData of Uint128 Uint128 Uint128 Uint128 (* reserve0, reserve1, vReserve0, vReserve1 *)

let zero_address = 0x0000000000000000000000000000000000000000
let zero_amount = Uint128 0
let zero_block = BNum 0
let bps = Uint128 10000
let none = None {ByStr20}
let bps = Uint128 10000
let precision = Uint256 1000000000000000000 (* for decimal calculations (18dp precision) *)
let short_alpha = Uint256 370301795963710 (* 2 * precision / 5401 *)
let long_alpha = Uint256 185168039996296 (* (2 * precision) / 10801 *)

(* constants used for get_fee *)
let zero_u256 = Uint256 0
let one_u256 = Uint256 1
let two_u256 = Uint256 2
let three_u256 = Uint256 3
let four_u256 = Uint256 4
let five_u256 = Uint256 5 
let nine_u256 = Uint256 9
let ten_u256 = Uint256 10
let twenty_u256 = Uint256 20
let twenty_seven_u256 = Uint256 27
let thirty_u256 = Uint256 30
let sixty_u256 = Uint256 60
let one_hundred_u256 = Uint256 100
let one_hundred_twenty_u256 = Uint256 120
let two_hundred_fifty_u256 = Uint256 250
let eight_hundred_thirty_six_u256 = Uint256 836
let nine_hundred_eighty_five_u256 = Uint256 985
let one_thousand_u256 = Uint256 1000
let ten_thousand_u256 = Uint256 10000
let twenty_thousand_u256 = Uint256 20000
let fifty_thousand_u256 = Uint256 50000
let two_hundred_thousand_u256 = Uint256 200000

(* constants used for AddLiquidity and AddLiquidityZIL *)
let one_hundred_and_twelve = Uint32 112
let q112_u256 = builtin pow two_u256 one_hundred_and_twelve

(* extracts the from_address from swap path of type Pair (from_address, to_address) *)
let get_from_address : Pair ByStr20 ByStr20 -> ByStr20 = @fst ByStr20 ByStr20

(* extracts the to_address from swap path of type Pair (from_address, to_address) *)
let get_to_address : Pair ByStr20 ByStr20 -> ByStr20 = @snd ByStr20 ByStr20

let one_msg =
  fun (msg : Message) =>
  let nil_msg = Nil {Message} in
  Cons {Message} msg nil_msg

let two_msgs =
  fun (msg1 : Message) =>
  fun (msg2 : Message) =>
  let msgs_tmp = one_msg msg2 in
  Cons {Message} msg1 msgs_tmp

let list_exists_bystr20 = @list_exists ByStr20

let get_amount_or_zero =
  fun (maybe : Option Uint128) =>
    match maybe with
    | Some amt => amt
    | None => zero_amount
    end

(* @dev: Convert Uint128 to Uint256 *)
let grow =
  fun (var : Uint128) =>
    let maybe_big = builtin to_uint256 var in
    match maybe_big with
    | Some big => big
    | None => Uint256 0 (* should never happen *)
    end

(* @dev: Convert Int256 to Uint128 *)
let shrink =
  fun (var : Int256) =>
    let maybe_small = builtin to_uint128 var in
    match maybe_small with
    | Some small => small
    | None => let one = Uint128 1 in builtin sub zero_amount one (* throw on overflow *)
    end

(* @dev: Convert Uint256 to Uint128 *)
let reduce =
  fun (var : Uint256) =>
    let maybe_small = builtin to_uint128 var in
    match maybe_small with
    | Some small => small
    | None => let one = Uint128 1 in builtin sub zero_amount one (* throw on overflow *)
    end

(* @dev: (x * y) / z *)
let frac =
  fun (x : Uint128) =>
  fun (y : Uint128) =>
  fun (z : Uint128) =>
    let x_u256 = grow x in
    let y_u256 = grow y in
    let z_u256 = grow z in
    let xy_u256 = builtin mul x_u256 y_u256 in
    let ans_u256 = builtin div xy_u256 z_u256 in
    reduce ans_u256

(* @dev: (x * y) / z in Uint256 *)
let frac_u256 =
  fun (x_u256: Uint256) => 
  fun (y_u256: Uint256) => 
  fun (z_u256: Uint256) => 
    let xy_u256 = builtin mul x_u256 y_u256 in
    builtin div xy_u256 z_u256

(* @dev: Given an amount of one token and pool reserves, return an equivalent amount of the tokenB *)
(* @solidity DMMLibrary.sol: 
  amountB = amountA.mul(reserveB) / reserveA 
*)
let quote =
  fun (amountA : Uint128) =>
  fun (reserveA : Uint128) =>
  fun (reserveB : Uint128) =>
    frac amountA reserveB reserveA

let list_or_empty =
  fun (maybe_list : Option (List ByStr20)) =>
  match maybe_list with
  | Some list => list
  | None => Nil {ByStr20}
  end

let add_once =
  fun (list : List ByStr20) =>
  fun (item : ByStr20) =>
    let f = fun (i : ByStr20) => builtin eq i item in
    let e = list_exists_bystr20 f list in
    match e with
    | True => list
    | False => Cons {ByStr20} item list
    end

let pool_exists =
  fun (list : List ByStr20) =>
  fun (item : ByStr20) =>
    let f = fun (i : ByStr20) => builtin eq i item in
    let e = list_exists_bystr20 f list in
    match e with
    | True => True
    | False => False
    end

(* @dev: Returns init_token pair *)
(* @solidity DMMLibrary.sol:
  (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
*)
let sort_token = 
  fun (path: Pair ByStr20 ByStr20 ) =>
  match path with
  | Pair token_in token_out =>
    let token_in_u256 = builtin to_uint256 token_in in
    let token_out_u256 = builtin to_uint256 token_out in
    let is_init_token0 = uint256_le token_in_u256 token_out_u256 in
    match is_init_token0 with 
    | True => path
    | False => Pair {ByStr20 ByStr20} token_out token_in
    end
  end

(* @dev: Returns reserves and vReserves in the correct order *)
(* @solidity DMMLibrary.sol: 
  (reserve0, reserve1, vReserve0, vReserve1, feeInPrecision) = IDMMPool(pool).getTradeInfo();
  (reserveA, reserveB, vReserveA, vReserveB) = tokenA == token0
    ? (reserve0, reserve1, vReserve0, vReserve1)
    : (reserve1, reserve0, vReserve1, vReserve0); 
*)
let get_trade_info = 
  fun (r_0: Uint128) =>
  fun (r_1: Uint128) =>
  fun (v_r_0: Uint128) =>
  fun (v_r_1: Uint128) =>
  fun (is_eq: Bool) =>
  fun (is_same_order: Bool) =>
  match is_eq with
  | True =>
    match is_same_order with
    | True =>
      ReserveData r_0 r_1 r_0 r_1
    | False =>
      ReserveData r_1 r_0 r_1 r_0
    end
  | False =>
    match is_same_order with
    | True =>
      ReserveData r_0 r_1 v_r_0 v_r_1
    | False =>
      ReserveData r_1 r_0 v_r_1 v_r_0
    end
  end

(* @dev: Returns x*y in precision *)
(* @solidity MathExt.sol: 
  return x.mul(y) / PRECISION;
*)
let mul_in_precision =
  fun (x : Uint256) =>
  fun (y : Uint256) =>
    let xy = builtin mul x y in
    builtin div xy precision

(* @dev: Used in unsafe_pow_in_precision *)
(* @solidity MathExt.sol: 
  zInPrecision = k % 2 != 0 ? xInPrecision : PRECISION; 
*)
let get_z_in_precision = 
  fun (x_in_precision: Uint256) =>
  fun (k: Uint256)=> 
    let remainder = builtin rem k two_u256 in
    let is_zero = builtin eq remainder zero_u256 in
    match is_zero with 
    | True => precision
    | False =>  x_in_precision
    end

let u32_to_nat_or_zero =
  fun (uint: Uint32) =>
    let nat = uint32_to_nat uint in
    match nat with
    | None => Zero (* uint32 always fits in a nat, so shld nvr happen *)
    | Some r => r
    end

(* @dev: Gets z_in_precision from the pair output of unsafe_pow_in_precision *)
(* @param: k (Pair x_in_precision z_in_precision) *)
let get_z_from_unsafe_pow_in_precision =
  fun (pair: Pair Uint256 (Pair Uint256 Uint256)) =>
  match pair with
  | Pair k xz_pair =>
    match xz_pair with
    | Pair x_in_precision z_in_precision => z_in_precision
    end
  end

(* @solidity MathExt.sol:
  zInPrecision = k % 2 != 0 ? xInPrecision : PRECISION;
  for (k /= 2; k != 0; k /= 2) {
      xInPrecision = (xInPrecision * xInPrecision) / PRECISION;
      if (k % 2 != 0) { zInPrecision = (zInPrecision * xInPrecision) / PRECISION; }
  } 
  return zInPrecision;
*)
let unsafe_pow_in_precision = 
  fun (x_in_precision: Uint256) =>
  fun (k: Uint256) =>
    let z_in_precision = get_z_in_precision x_in_precision k in

    let m = Uint32 128 in
    let m_nat = u32_to_nat_or_zero m in (* max no of loops is fixed at 128 times *)

    let xz_pair = Pair {Uint256 Uint256} x_in_precision z_in_precision in
    let init_pair = Pair {Uint256 (Pair Uint256 Uint256)} k xz_pair in

    let foldk = @nat_foldk (Pair Uint256 (Pair Uint256 Uint256)) in (* k (Pair x_in_precision z_in_precision) *)
    let iter =
      fun (n : Pair Uint256 (Pair Uint256 Uint256)) =>
      fun (ignore : Nat) =>
      fun (recurse : (Pair Uint256 (Pair Uint256 Uint256) -> Pair Uint256 (Pair Uint256 Uint256))) =>
        match n with
        | Pair k cur_xz_pair =>
          let is_k_zero = builtin eq k zero_u256 in
          match is_k_zero with
          | True => n
          | False => 
            match cur_xz_pair with
            | Pair x_in_precision z_in_precision =>
              let new_k = builtin div k two_u256 in
              let inter_x_in_precision = builtin mul x_in_precision x_in_precision in
              let new_x_in_precision = builtin div inter_x_in_precision precision in
              let mod = builtin rem new_k two_u256 in
              let is_odd = builtin eq mod one_u256 in
              match is_odd with
              | False =>
                let new_xz_pair = Pair {Uint256 Uint256} new_x_in_precision z_in_precision in
                let new_accum = Pair {Uint256 (Pair Uint256 Uint256)} new_k new_xz_pair in
                recurse new_accum
              | True =>
                let inter_z_in_precision = builtin mul z_in_precision x_in_precision in
                let new_z_in_precision = builtin div inter_z_in_precision precision in

                let new_xz_pair = Pair {Uint256 Uint256} new_x_in_precision new_z_in_precision in
                let new_accum = Pair {Uint256 (Pair Uint256 Uint256)} new_k new_xz_pair in
                recurse new_accum
              end
            end
          end
        end
      in
    foldk iter init_pair m_nat

(* @solidity VolumeTrendRecorder.sol: 
  return ((precision - alpha) * ema + alpha * value) / precision; 
*)
let get_ema =
  fun (ema : Uint256) =>
  fun (alpha : Uint256) =>
  fun (value : Uint128) =>
    let v = grow value in
    let i_a = builtin sub precision alpha in
    let a = builtin mul i_a ema in
    let b = builtin mul alpha v in
    let n = builtin add a b in
    builtin div n precision

(* @dev: Returns r_factor_in_precision in Uint256 from short_ema and long_ema *)
(* @solidity VolumeTrendRecorder.sol: 
  if (_longEMA == 0) { return 0; }
  return (_shortEMA * MathExt.PRECISION) / _longEMA; 
*)
let calculate_r_factor = 
  fun (short_ema : Uint256) =>
  fun (long_ema : Uint256) =>
    let is_zero = builtin eq long_ema zero_u256 in 
    match is_zero with
    | True => zero_u256
    | False =>
      frac_u256 short_ema precision long_ema
    end

(* @dev: Returns rFactor in Precision for this trade *)
(* @solidity VolumeTrendRecorder.sol:
  skipBlock = blockNumber - lastTradeBlock;
  if (skipBlock == 0) { return calculateRFactor(shortEMA, longEMA); }

  _shortEMA = (newEMA(shortEMA, SHORT_ALPHA, currentBlockVolume)).mulInPrecision(
      (PRECISION - SHORT_ALPHA).unsafePowInPrecision(skipBlock - 1));

  _longEMA = (newEMA(longEMA, LONG_ALPHA, currentBlockVolume)).mulInPrecision(
      (PRECISION - LONG_ALPHA).unsafePowInPrecision(skipBlock - 1));
  return calculateRFactor(_shortEMA, _longEMA);}
*)
let get_r_factor = 
  fun (current_block: BNum) =>
  fun (last_trade_block: BNum) =>
  fun (current_block_volume: Uint128) =>
  fun (short_ema: Uint256) =>
  fun (long_ema: Uint256) =>
    let block_skipped_int256 = builtin bsub current_block last_trade_block in
    let blocks_skipped_u128 = shrink block_skipped_int256 in
    let blocks_skipped_u256 = grow blocks_skipped_u128 in
    let is_zero = builtin eq blocks_skipped_u256 zero_u256 in
    match is_zero with
    | True => calculate_r_factor short_ema long_ema
    | False =>
      let block_skipped_minus_one = builtin sub blocks_skipped_u256 one_u256 in
      let short_e = get_ema short_ema short_alpha current_block_volume in
      let long_e = get_ema long_ema long_alpha current_block_volume in
      let s_e = 
        let a = builtin sub precision short_alpha in
        let b = mul_in_precision short_e a in
        let pair = unsafe_pow_in_precision b block_skipped_minus_one in
        get_z_from_unsafe_pow_in_precision pair
      in
      let l_e = 
        let a = builtin sub precision long_alpha in
        let b = mul_in_precision long_e a in
        let pair = unsafe_pow_in_precision b block_skipped_minus_one in
        get_z_from_unsafe_pow_in_precision pair
      in
      calculate_r_factor s_e l_e
    end

(* @dev: Calculates fee in Uint256 from r_factor_in_precision *)
(* @solidity FeeFormula.sol:
  if (rFactorInPrecision >= R0) { return C0; } 
  else if (rFactorInPrecision >= PRECISION) {
    // C1 + A * (r-U)^3 + b * (r -U)
    if (rFactorInPrecision > U) {
      tmp = rFactorInPrecision - U;
      tmp3 = tmp.unsafePowInPrecision(3);
      return (C1.add(A.mulInPrecision(tmp3)).add(B.mulInPrecision(tmp))) / 10000;
    } else {
      tmp = U - rFactorInPrecision;
      tmp3 = tmp.unsafePowInPrecision(3);
      return C1.sub(A.mulInPrecision(tmp3)).sub(B.mulInPrecision(tmp)) / 10000;
    }
  } else {
    // [ C2 + sign(r - G) *  F * (r-G) ^2 / (L + (r-G) ^2) ] / 10000
    tmp = (rFactorInPrecision > G ? (rFactorInPrecision - G) : (G - rFactorInPrecision));
    tmp = tmp.unsafePowInPrecision(2);
    tmp2 = F.mul(tmp).div(tmp.add(L));
    if (rFactorInPrecision > G) { return C2.add(tmp2) / 10000; }
    else { return C2.sub(tmp2) / 10000; }
  }
*)
let get_fee = 
  fun (r_factor_in_precision: Uint256) => 
    let r0 = Uint256 1477405064814996100 in
    let c2 = Uint256 20036905816356657810 in
    let c0 = frac_u256 sixty_u256 precision ten_thousand_u256 in
    let a = frac_u256 twenty_thousand_u256 precision twenty_seven_u256 in
    let b = frac_u256 two_hundred_fifty_u256 precision nine_u256 in
    let c1 = frac_u256 nine_hundred_eighty_five_u256 precision twenty_seven_u256 in
    let u = frac_u256 one_hundred_twenty_u256 precision one_hundred_u256 in
    let g = frac_u256 eight_hundred_thirty_six_u256 precision one_thousand_u256 in
    let f = builtin mul five_u256 precision in
    let l = frac_u256 two_u256 precision ten_thousand_u256 in
    let is_ge_r0 = uint256_ge r_factor_in_precision r0 in
    match is_ge_r0 with 
    | True => c0
    | False => 
      let is_ge_precision = uint256_ge r_factor_in_precision precision in
      match is_ge_precision with
      | True =>
        (* C1 + A * (r-U)^3 + b * (r -U) *)
        let is_gt_u = uint256_gt r_factor_in_precision u in
        match is_gt_u with
        | True =>
          let tmp = builtin sub r_factor_in_precision u in
          let tmp3 = 
            let pair = unsafe_pow_in_precision tmp three_u256 in
            get_z_from_unsafe_pow_in_precision pair
          in
          let a_tmp3 = mul_in_precision a tmp3 in
          let b_tmp = mul_in_precision b tmp in
          let c1_add_a = builtin add c1 a_tmp3 in
          let c1_add_a_add_b = builtin add c1_add_a b_tmp in
          builtin div c1_add_a_add_b ten_thousand_u256
        | False =>
          let tmp = builtin sub u r_factor_in_precision in
          let tmp3 = 
            let pair = unsafe_pow_in_precision tmp three_u256 in
            get_z_from_unsafe_pow_in_precision pair
          in
          let a_tmp3 = mul_in_precision a tmp3 in
          let b_tmp = mul_in_precision b tmp in
          let c1_sub_a = builtin sub c1 a_tmp3 in
          let c1_sub_a_sub_b = builtin sub c1_sub_a b_tmp in
          builtin div c1_sub_a_sub_b ten_thousand_u256
        end
      | False =>
        (* [ C2 + sign(r - G) *  F * (r-G) ^2 / (L + (r-G) ^2) ] / 10000 *)
        let is_gt_g = uint256_gt r_factor_in_precision g in
        let tmp = match is_gt_g with
        | True => 
          let r_sub_g = builtin sub r_factor_in_precision g in
          let pair = unsafe_pow_in_precision r_sub_g two_u256 in
          get_z_from_unsafe_pow_in_precision pair
        | False => 
          let g_sub_r = builtin sub g r_factor_in_precision in
          let pair = unsafe_pow_in_precision g_sub_r two_u256 in 
          get_z_from_unsafe_pow_in_precision pair
        end in
        let tmp_add_l = builtin add tmp l in
        let tmp2 = frac_u256 f tmp tmp_add_l in
        match is_gt_g with 
        | True =>
          let c2_add_tmp2 = builtin add c2 tmp2 in
          builtin div c2_add_tmp2 ten_thousand_u256
        | False =>
          let c2_sub_tmp2 = builtin sub c2 tmp2 in
          builtin div c2_sub_tmp2 ten_thousand_u256
        end
      end
    end

(* @dev: Returns final_fee in Uint256 *)
(* @solidity DMMPool.sol:
  if (_ampBps <= 20000) { return feeInPrecision; } 
  else if (_ampBps <= 50000) { return (feeInPrecision * 20) / 30; }
  else if (_ampBps <= 200000) { return (feeInPrecision * 10) / 30; }
  else { return (feeInPrecision * 4) / 30; }
} *)
let get_final_fee = 
  fun (fee_in_precision : Uint256) =>
  fun (amp_bps : Uint128) =>
    let amp_bps_u256 = grow amp_bps in
    let is_le_twenty_thousand = uint256_le amp_bps_u256 twenty_thousand_u256 in 
    match is_le_twenty_thousand with
    | True => fee_in_precision
    | False =>
      let is_le_fifty_thousand_u256 = uint256_le amp_bps_u256 fifty_thousand_u256 in
      match is_le_fifty_thousand_u256 with 
      | True => 
        frac_u256 fee_in_precision twenty_u256 thirty_u256 
      | False =>
        let is_le_two_hundred_thousand_u256 = uint256_le amp_bps_u256 two_hundred_thousand_u256 in
        match is_le_two_hundred_thousand_u256 with
        | True => 
          frac_u256 fee_in_precision ten_u256 thirty_u256
        | False => 
          frac_u256 fee_in_precision four_u256 thirty_u256
        end
      end
    end

(* @dev: Calculates amount_out *)
(* @solidity DMMLibrary.sol:
  require(amountIn > 0, "DMMLibrary: INSUFFICIENT_INPUT_AMOUNT");
  require(reserveIn > 0 && reserveOut > 0, "DMMLibrary: INSUFFICIENT_LIQUIDITY");
  amountInWithFee = amountIn.mul(PRECISION.sub(feeInPrecision)).div(PRECISION);
  numerator = amountInWithFee.mul(vReserveOut);
  denominator = vReserveIn.add(amountInWithFee);
  amountOut = numerator.div(denominator);
  require(reserveOut > amountOut, "DMMLibrary: INSUFFICIENT_LIQUIDITY");
} *)
let get_amount_out = 
  fun (amount_in: Uint128) =>
  fun (v_reserve_in: Uint128) =>
  fun (v_reserve_out: Uint128) =>
  fun (fee_in_precision: Uint256) =>
    let precision_u128 = reduce precision in
    let fee_in_precision_u128 = reduce fee_in_precision in
    let precision_sub_fee = builtin sub precision_u128 fee_in_precision_u128 in
    let amount_in_with_fee = frac amount_in precision_sub_fee precision_u128 in
    let numerator = builtin mul amount_in_with_fee v_reserve_out in
    let denominator = builtin add v_reserve_in amount_in_with_fee in
    builtin div numerator denominator

(* @dev: Calculates amount_in *)
(* @solidity DMMLibrary.sol:
  require(amountOut > 0, "DMMLibrary: INSUFFICIENT_OUTPUT_AMOUNT");
  require(reserveIn > 0 && reserveOut > amountOut, "DMMLibrary: INSUFFICIENT_LIQUIDITY");
  numerator = vReserveIn.mul(amountOut);
  denominator = vReserveOut.sub(amountOut);
  amountIn = numerator.div(denominator).add(1);
  // amountIn = floor(amountIN *PRECISION / (PRECISION - feeInPrecision));
  numerator = amountIn.mul(PRECISION);
  denominator = PRECISION.sub(feeInPrecision);
  amountIn = numerator.add(denominator - 1).div(denominator); 
*)
let get_amount_in = 
  fun (amount_out: Uint128) =>
  fun (v_reserve_in: Uint128) =>
  fun (v_reserve_out: Uint128) =>
  fun (fee_in_precision: Uint256) =>
    let one = Uint128 1 in
    let precision_u128 = reduce precision in
    let fee_in_precision_u128 = reduce fee_in_precision in
    let n = builtin mul v_reserve_in amount_out in
    let d = builtin sub v_reserve_out amount_out in
    let a_i = builtin div n d in
    let amount_in = builtin add a_i one in
    let numerator = builtin mul amount_in precision_u128 in
    let denominator = builtin sub precision_u128 fee_in_precision_u128 in
    let denominator_minus_one = builtin sub denominator one in
    let numerator_add_denominator_minus_one = builtin add numerator denominator_minus_one in
    builtin div numerator_add_denominator_minus_one denominator

(* Error events *)
type Error =
| CodeNotSelf
| CodeNotGovernor
| CodeNotPendingGovernor
| CodeDuplicateUnamplifiedPool
| CodeInvalidPool
| CodeInvalidWZIL
| CodeInsufficientAmount
| CodeInsufficientLiquidity
| CodeBlockExpired
| CodeOutOfBoundVReserve
| CodeInsufficientInputAmt
| CodeInsufficientOutputAmt
| CodeExcessiveInputAmt

let make_error =
  fun (result : Error) =>
    let result_code =
      match result with
      | CodeNotSelf                   => Int32 -1
      | CodeNotGovernor               => Int32 -2
      | CodeNotPendingGovernor        => Int32 -3
      | CodeDuplicateUnamplifiedPool  => Int32 -4
      | CodeInvalidPool               => Int32 -5
      | CodeInvalidWZIL               => Int32 -6
      | CodeInsufficientAmount        => Int32 -7
      | CodeInsufficientLiquidity     => Int32 -8
      | CodeBlockExpired              => Int32 -9
      | CodeOutOfBoundVReserve        => Int32 -10
      | CodeInsufficientInputAmt      => Int32 -11
      | CodeInsufficientOutputAmt     => Int32 -12
      | CodeExcessiveInputAmt         => Int32 -13
      end
    in
    { _exception : "Error"; code : result_code }

contract ZilSwapRouter
(
  init_governor : ByStr20,
  init_codehash : ByStr32,
  init_wZIL_address : ByStr20 with contract field balances: Map ByStr20 Uint128 end
)

field governor : ByStr20 = init_governor
field pending_governor : Option ByStr20 = none
field pool_codehash : ByStr32 = init_codehash
field fee_configuration : Pair ByStr20 Uint128 = Pair {ByStr20 Uint128} zero_address zero_amount (* fee_to fee_bps *)
field wZIL_address: ByStr20 with contract field balances: Map ByStr20 Uint128 end = init_wZIL_address (* Should not be changed *)

field all_pools : List ByStr20 = Nil {ByStr20}
field pools : Map ByStr20 (Map ByStr20 (List ByStr20)) = Emp ByStr20 (Map ByStr20 (List ByStr20))
field unamplified_pools : Map ByStr20 (Map ByStr20 ByStr20) = Emp ByStr20 (Map ByStr20 ByStr20)

field amt_out : Uint128 = zero_amount
field amt_in : Uint128 = zero_amount

(**************************************)
(*             Procedures             *)
(**************************************)

procedure ThrowError(err : Error)
  e = make_error err;
  throw e
end

(*** Factory ***)

procedure IsSelf(address : ByStr20)
  is_self = builtin eq _this_address address;
  match is_self with
  | True =>
  | False =>
    err = CodeNotSelf;
    ThrowError err
  end
end

(* @dev: Validate the pool contract with correct codehash *)
procedure IsValidPoolContract(pool_address : ByStr20)
  maybe_pool <- & pool_address as ByStr20 with _codehash end;
  match maybe_pool with
  | None =>
  | Some p =>
    required_codehash <- pool_codehash;
    codehash <- & p._codehash;
    is_valid_pool = builtin eq codehash required_codehash;
    match is_valid_pool with
    | True =>
    | False =>
      err = CodeInvalidPool;
      ThrowError err
    end
  end
end

procedure AddOnceToPools(tokenA : ByStr20, tokenB : ByStr20, pool : ByStr20)
  p <- pools[tokenA][tokenB];
  list = list_or_empty p;
  p_new = add_once list pool;
  pools[tokenA][tokenB] := p_new
end

(* @dev: Verifies if a pool with a token pair of tokenA-tokenB already exists *)
(* @dev: Duplicate pools are not allowed to be added to the contract *)
procedure VerifyPoolAddress(tokenA : ByStr20, tokenB : ByStr20, pool: ByStr20)
  p <- pools[tokenA][tokenB];
  list = list_or_empty p;
  e = pool_exists list pool;
  match e with 
  | True =>
  | False =>
    err = CodeInvalidPool;
    ThrowError err
  end
end

(* @dev: Verify if address is equal to wZIL_address *)
procedure VerifyWZILAddress(address: ByStr20)
  wZIL <- wZIL_address;
  is_wZIL = builtin eq wZIL address;
  match is_wZIL with
  | True =>
  | False =>
    err = CodeInvalidWZIL;
    ThrowError err
  end
end

(* @dev: Validates that the tokenAmount and the pool reserves are more than 0 *)
(* @solidity DMMLibrary.sol:
  require(amountA > 0, "DMMLibrary: INSUFFICIENT_AMOUNT");
  require(reserveA > 0 && reserveB > 0, "DMMLibrary: INSUFFICIENT_LIQUIDITY");
  amountB = amountA.mul(reserveB) / reserveA;
*)
procedure Quote(amountA : Uint128, reserveA : Uint128, reserveB : Uint128)
  is_sufficient_amt = uint128_gt amountA zero_amount;
  match is_sufficient_amt with
  | True =>
    is_sufficient_liquidity = 
      let reserveA_ = uint128_gt reserveA zero_amount in 
      let reserveB_ = uint128_gt reserveB zero_amount in 
      andb reserveA_ reserveB_;
    match is_sufficient_liquidity with
    | True =>
    | False =>
      err = CodeInsufficientLiquidity;
      ThrowError err
    end
  | False =>
    err = CodeInsufficientAmount;
    ThrowError err
  end
end

(* @dev: Checks if amountA >= AmountB *)
procedure VerifyAmount(amountA : Uint128, amountB : Uint128)
  is_sufficient_amount = uint128_ge amountA amountB;
  match is_sufficient_amount with
  | True =>
  | False =>
    err = CodeInsufficientAmount;
    ThrowError err
  end
end

(* @dev: Checks if current_block >= deadline_block *)
procedure VerifyBlock(deadline_block : BNum)
  current_block <- & BLOCKNUMBER;
  is_expired = builtin blt deadline_block current_block;
  match is_expired with
  | True =>
    err = CodeBlockExpired;
    ThrowError err
  | False =>
  end
end

(* @dev: Checks if r_in > amount_in && r_out > amount_out *)
procedure VerifySufficientLiquidity(r_in: Uint128, r_out: Uint128, amount_in: Uint128, amount_out: Uint128)
  is_sufficient_liquidity = 
    let a = uint128_gt r_in amount_in in
    let b = uint128_gt r_out amount_out in
    andb a b;
  match is_sufficient_liquidity with
  | True =>
  | False =>
  err = CodeInsufficientLiquidity;
  ThrowError err
  end
end

(* @dev: Checks if amount in more than 0 *)
procedure VerifyValidAmountIn(amount_in: Uint128)
  is_valid_amount_in = let a = builtin eq amount_in zero_amount in negb a;
  match is_valid_amount_in with
  | True => | False =>
    err = CodeInsufficientInputAmt;
    ThrowError err
  end
end

(*** Transfers ***)

(* @dev: Transfer zil from contract balance to the user *)
procedure Send(amount: Uint128, to_address : ByStr20)
  msg = { _tag : "AddFunds"; _recipient: to_address; _amount: amount };
  msgs = one_msg msg;
  send msgs
end

procedure TransferZRC2(token_address: ByStr20, to: ByStr20, amount: Uint128)
  msg_to_zrc2 = {
    _tag: "Transfer";
    _recipient: token_address;
    _amount: zero_amount;
    to: to;
    amount: amount
  };
  msg = one_msg msg_to_zrc2;
  send msg
end

procedure TransferFromZRC2(token_address: ByStr20, from: ByStr20, to: ByStr20, amount: Uint128)
  msg_to_zrc2 = {
    _tag: "TransferFrom";
    _recipient: token_address;
    _amount: zero_amount;
    from: from;
    to: to;
    amount: amount
  };
  msg = one_msg msg_to_zrc2;
  send msg
end

(* @dev: Transfers this contract's ZRC2 tokens into pool *)
(* @param: path: token_in token_out *)
procedure TransferZRC2ToPool(
  pool: ByStr20,
  path: Pair ByStr20 ByStr20,
  amount_in: Uint128
)
  match path with
  | Pair token_in token_out =>
    init_token_pair = sort_token path;
    match init_token_pair with
    | Pair init_token0 init_token1 =>
      is_same_order = builtin eq token_in init_token0;

      (* _swap *)
      match is_same_order with
      | True =>
      (* Transfer exact amt of init_token0 to pool *)
        msg_to_token = {_tag: "Transfer"; _recipient: init_token0; _amount: zero_amount;
                        to: pool; amount: amount_in};
        msgs = one_msg msg_to_token;
        send msgs
      | False =>
      (* Transfer exact amt of init_token1 to pool *)
        msg_to_token = {_tag: "Transfer"; _recipient: init_token1; _amount: zero_amount;
                        to: pool; amount: amount_in};
        msgs = one_msg msg_to_token;
        send msgs
      end
    end
  end
end

(* @dev: Transfers _sender's ZRC2 tokens into pool *)
(* @param: path: token_in token_out *)
procedure TransferFromZRC2ToPool(
  pool: ByStr20,
  path: Pair ByStr20 ByStr20,
  amount_in: Uint128
)
  match path with
  | Pair token_in token_out =>
    init_token_pair = sort_token path;
    match init_token_pair with
    | Pair init_token0 init_token1 =>
      is_same_order = builtin eq token_in init_token0;

      (* _swap *)
      match is_same_order with
      | True =>
      (* Transfer exact amt of init_token0 to pool *)
        msg_to_token = {_tag: "TransferFrom"; _recipient: init_token0; _amount: zero_amount;
                        from: _sender; to: pool; amount: amount_in};
        msgs = one_msg msg_to_token;
        send msgs
      | False =>
      (* Transfer exact amt of init_token1 to pool *)
        msg_to_token = {_tag: "TransferFrom"; _recipient: init_token1; _amount: zero_amount;
                        from: _sender; to: pool; amount: amount_in};
        msgs = one_msg msg_to_token;
        send msgs
      end
    end
  end
end

(* Calls Mint transition on wZIL contract to wrap ZIL into wZIL *)
procedure WrapZIL(amount: Uint128)
  wZIL <- wZIL_address;
  msg_to_zrc2 = {
    _tag: "Mint";
    _recipient: wZIL;
    _amount: amount
  };
  msg = one_msg msg_to_zrc2;
  send msg
end

(* Calls Burn transition on wZIL contract to unwrap wZIL into ZIL *)
procedure UnwrapZIL(amount: Uint128)
  wZIL <- wZIL_address;
  msg_to_token = {
    _tag: "Burn";
    _recipient: wZIL;
    _amount: zero_amount;
    amount: amount
  };

  msg = one_msg msg_to_token;
  send msg
end

(*** Swaps ***)

(* @dev: Calculates the amount_out and assigns to amt_out *)
(* @solidity DMMLibrary.sol:
  amounts = new uint256[](path.length);
  amounts[0] = amountIn;
  for (i; i < path.length - 1; i++) {
    (reserveIn, reserveOut, vReserveIn, vReserveOut, feeInPrecision) = getTradeInfo(poolsPath[i], path[i], path[i + 1]);
    amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut, vReserveIn, vReserveOut, feeInPrecision);
  }
*)
procedure GetAmountOut(
  amount_in: Uint128,
  pool: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  VerifyBlock deadline_block;
  is_valid_amount_in = uint128_gt amount_in zero_amount;
  match is_valid_amount_in with
  | True =>
  | False =>
    err = CodeInsufficientInputAmt;
    ThrowError err
  end;

  match path with 
  | Pair token_in token_out =>
    init_token_pair = sort_token path;
    match init_token_pair with
    | Pair init_token0 init_token1 =>
      VerifyPoolAddress init_token0 init_token1 pool;

      r_0 <- & pool.reserve0;
      r_1 <- & pool.reserve1;
      v_r_0 <- & pool.v_reserve0;
      v_r_1 <- & pool.v_reserve1;

      amp <- & pool.amp_bps;
      short_ema <- & pool.short_ema;
      long_ema <- & pool.long_ema;
      current_block_volume <- & pool.current_block_volume;
      current_block <- & BLOCKNUMBER;

      last <- & pool.last_trade_block;
      is_first_trade = builtin eq last zero_block;
      last_block = match is_first_trade with
      | True => current_block
      | False => last
      end;

      r_factor_in_precision = get_r_factor current_block last_block current_block_volume short_ema long_ema;
      intermediate_fee = get_fee r_factor_in_precision;
      fee_in_precision = get_final_fee intermediate_fee amp;

      is_eq = builtin eq amp bps;
      is_same_order = builtin eq token_in init_token0;

      data = get_trade_info r_0 r_1 v_r_0 v_r_1 is_eq is_same_order;
      match data with 
      | ReserveData r_in r_out v_r_in v_r_out =>
        VerifySufficientLiquidity r_in r_out zero_amount zero_amount;

        amount_out = get_amount_out amount_in v_r_in v_r_out fee_in_precision;
        amt_out := amount_out;

        is_valid_reserve_out = uint128_gt r_out amount_out;
        match is_valid_reserve_out with 
        | True => | False => 
          err = CodeInsufficientLiquidity;
          ThrowError err
        end
      end
    end
  end
end

(* @dev: Calculates the amount_in and assigns to amt_in *)
(* @solidity DMMLibrary.sol:
  amounts = new [](path.length);
  amounts[amounts.length - 1] = amountOut;
  for ( i = path.length - 1; i > 0; i--) {
    (reserveIn, reserveOut, vReserveIn, vReserveOut, feeInPrecision) = getTradeInfo(poolsPath[i - 1], path[i - 1], path[i]);
    amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut, vReserveIn, vReserveOut, feeInPrecision);
  }
*)
procedure GetAmountIn(
  amount_out: Uint128,
  pool: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  VerifyBlock deadline_block;
  is_valid_amount_out = uint128_gt amount_out zero_amount;
  match is_valid_amount_out with
  | True =>
  | False =>
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  match path with
  | Pair token_in token_out => 
    init_token_pair = sort_token path;
    match init_token_pair with
    | Pair init_token0 init_token1 =>
      VerifyPoolAddress init_token0 init_token1 pool;

      r_0 <- & pool.reserve0;
      r_1 <- & pool.reserve1;
      v_r_0 <- & pool.v_reserve0;
      v_r_1 <- & pool.v_reserve1;

      amp <- & pool.amp_bps;
      short_ema <- & pool.short_ema;
      long_ema <- & pool.long_ema;
      current_block_volume <- & pool.current_block_volume;
      current_block <- & BLOCKNUMBER;

      last <- & pool.last_trade_block;
      is_first_trade = builtin eq last zero_block;
      last_block = match is_first_trade with
      | True => current_block
      | False => last
      end;

      r_factor_in_precision = get_r_factor current_block last_block current_block_volume short_ema long_ema;
      intermediate_fee = get_fee r_factor_in_precision;
      fee_in_precision = get_final_fee intermediate_fee amp;

      is_eq = builtin eq amp bps;
      is_same_order = builtin eq token_in init_token0;

      data = get_trade_info r_0 r_1 v_r_0 v_r_1 is_eq is_same_order;
      match data with 
      | ReserveData r_in r_out v_r_in v_r_out =>
        VerifySufficientLiquidity r_in r_out zero_amount amount_out;

        amount_in = get_amount_in amount_out v_r_in v_r_out fee_in_precision;
        amt_in := amount_in
      end
    end
  end
end

(* @dev: Swaps ZRC2 for ZRC2 in one pool *)
(* @param path: token_in token_out *)
(* @solidity DMMRouter02.sol:
  for (uint256 i; i < path.length - 1; i++) {
    (IERC20 input, IERC20 output) = (path[i], path[i + 1]);
    (IERC20 token0, ) = DMMLibrary.sortTokens(input, output);
    uint256 amountOut = amounts[i + 1];
    (uint256 amount0Out, uint256 amount1Out) = input == token0
        ? (uint256(0), amountOut)
        : (amountOut, uint256(0));
    address to = i < path.length - 2 ? poolsPath[i + 1] : _to;
    IDMMPool(poolsPath[i]).swap(amount0Out, amount1Out, to, new bytes(0));
  }
*)
procedure SwapZRC2Once(
  pool: ByStr20,
  path: Pair ByStr20 ByStr20, 
  amount_out: Uint128,
  to: ByStr20
)
  match path with
  | Pair token_in token_out =>
    init_token_pair = sort_token path;
    match init_token_pair with
    | Pair init_token0 init_token1 =>
      is_same_order = builtin eq token_in init_token0;

      (* _swap *)
      match is_same_order with
      | True =>
      (* Swap exact amt of init_token0 for init_token1 *)
        amount0_out = zero_amount;
        amount1_out = amount_out;
        msg_to_pool = {_tag: "Swap"; _recipient: pool; _amount: zero_amount;
                      amount0_out: amount0_out; amount1_out: amount1_out; to: to};
        msgs = one_msg msg_to_pool;
        send msgs
      | False =>
      (* Swap exact amt of init_token1 for init_token0 *)
        amount0_out = amount_out;
        amount1_out = zero_amount;
        msg_to_pool = {_tag: "Swap"; _recipient: pool; _amount: zero_amount;
                      amount0_out: amount0_out; amount1_out: amount1_out; to: to};
        msgs = one_msg msg_to_pool;
        send msgs
      end
    end
  end
end

(*** Governance ***)
procedure IsGovernor(address: ByStr20)
  g <- governor;
  is_owner = builtin eq g address;
  match is_owner with
  | True =>
  | False =>
    err = CodeNotGovernor;
    ThrowError err
  end
end

procedure IsPendingGovernor(address: ByStr20)
  maybe_pending_governor <- pending_governor;
  match maybe_pending_governor with
  | Some new_govenor =>
    is_pending_governor = builtin eq new_govenor address;
    match is_pending_governor with
    | True =>
    | False =>
      err = CodeNotPendingGovernor;
      ThrowError err
    end
  | None =>
    err = CodeNotPendingGovernor;
    ThrowError err
  end
end

(***************************************)
(*         Factory Transitions         *)
(***************************************)

transition AddPool(
  pool : ByStr20 with contract
    field token0 : ByStr20,
    field token1 : ByStr20,
    field factory : ByStr20,
    field amp_bps : Uint128
  end
)
  (* validate factory *)
  f <- & pool.factory;
  IsSelf f;

  IsValidPoolContract pool;

  (* TODO: not possible now as init var cannot be fetched *)
  (* validate name and symbol *)
  (* t0 <- & pool.token0;
  symbol <- & t0 as ByStr20 with contract field symbol : String end;
  match symbol with
  | Some _ =>
  | None =>
    err = CodeNotSelf;
    ThrowError err
  end *)

  (* populate pool mapping for both directions *)
  token0 <- & pool.token0;
  token1 <- & pool.token1;
  AddOnceToPools token0 token1 pool;
  AddOnceToPools token1 token0 pool;

  amp_bps <- & pool.amp_bps;
  is_unamplified = builtin eq bps amp_bps;
  match is_unamplified with
  | False =>
  | True =>
    (* only allow one umaplified pool *)
    is_exists <- exists unamplified_pools[token0][token1];
    match is_exists with
    | False =>
    | True =>
      err = CodeDuplicateUnamplifiedPool;
      ThrowError err
    end;
    unamplified_pools[token0][token1] := pool;
    unamplified_pools[token1][token0] := pool
  end;

  ap <- all_pools;
  new_ap = add_once ap pool;
  all_pools := new_ap;

  e = {_eventname: "PoolCreated"; token0: token0; token1: token1; amp_bps: amp_bps};
  event e
end

(*** Governance ***)

(* @dev: Only governor should be able to set fee config *)
(* @param config: fee_to fee_bps *)
transition SetFeeConfiguration(config: Pair ByStr20 Uint128)
  IsGovernor _sender;
  fee_configuration := config;
  e = {_eventname: "FeeConfigurationSet"; fee_configuration: config};
  event e
end

(* @dev: Only governor can set wZIL address *)
(* @dev: Should not be used unless there is a change in wZIL contract address *)
transition SetWZILAddress(
  new_wZIL_address: ByStr20 with contract 
    field balances: Map ByStr20 Uint128 
  end
)
  IsGovernor _sender;
  wZIL_address := new_wZIL_address;
  e = {_eventname: "wZILAddressSet"; new_wZIL_address: new_wZIL_address};
  event e
end

(* @dev: Transfers contract governorship to a new address. The new address must call the AcceptGovernorship transition to finalize the transfer. *)
(* @param new_governor: Address of the new governor.                                                                                    *)
transition SetGovernor(new_governor: ByStr20)
  IsGovernor _sender;
  g = Some {ByStr20} new_governor;
  pending_governor := g;
  e = {_eventname : "GovernanceTransferInitiated"; governor : _sender; pending_governor : new_governor};
  event e
end

(* @dev: Finalizes transfer of contract governance. Must be called by the pending governor. *)
transition AcceptGovernance()
  IsPendingGovernor _sender;
  previous_governor <- governor;
  governor := _sender;
  pending_governor := none;
  e = {_eventname : "GovernanceTransferAccepted"; previous_governor : previous_governor; governor : _sender};
  event e
end

(***************************************)
(*          Router Transitions         *)
(***************************************)

(*** LIQUIDITY ***)

(* @param: Order of tokens does not matter*)
(* @param: But ideally, tokenA < tokenB (ie tokenA == token0, tokenB == token1 on Pool) *)
(* @param: v_reserve_ratio_bounds only applies for amp_pool *)
(* @solidity addLiquidity DMMRouter02.sol:
  verifyPoolAddress(tokenA, tokenB, pool);
  (amountA, amountB) = _addLiquidity(tokenA, tokenB, pool, amountADesired, amountBDesired, amountAMin, amountBMin, vReserveRatioBounds);
  // using tokenA.safeTransferFrom will get "Stack too deep"
  SafeERC20.safeTransferFrom(tokenA, msg.sender, pool, amountA);
  SafeERC20.safeTransferFrom(tokenB, msg.sender, pool, amountB);
  liquidity = IDMMPool(pool).mint(to);
*)
(* @solidity _addLiquidity DMMRouter02.sol:
  (reserveA, reserveB, vReserveA, vReserveB, ) = DMMLibrary.getTradeInfo(pool, tokenA, tokenB);
  if (reserveA == 0 && reserveB == 0) { (amountA, amountB) = (amountADesired, amountBDesired); } 
  else {
    amountBOptimal = DMMLibrary.quote(amountADesired, reserveA, reserveB);
    if (amountBOptimal <= amountBDesired) {
      require(amountBOptimal >= amountBMin, "DMMRouter: INSUFFICIENT_B_AMOUNT");
      (amountA, amountB) = (amountADesired, amountBOptimal);
    } else {
      amountAOptimal = DMMLibrary.quote(amountBDesired, reserveB, reserveA);
      assert(amountAOptimal <= amountADesired);
      require(amountAOptimal >= amountAMin, "DMMRouter: INSUFFICIENT_A_AMOUNT");
      (amountA, amountB) = (amountAOptimal, amountBDesired);
    }
    currentRate = (vReserveB * Q112) / vReserveA;
    require( currentRate >= vReserveRatioBounds[0] && currentRate <= vReserveRatioBounds[1],
        "DMMRouter: OUT_OF_BOUNDS_VRESERVE"
    );
  }
*)
transition AddLiquidity(
  tokenA : ByStr20,
  tokenB : ByStr20,
  pool: ByStr20 with contract 
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field amp_bps : Uint128
  end,
  amountA_desired: Uint128,
  amountB_desired: Uint128,
  amountA_min: Uint128,
  amountB_min: Uint128,
  v_reserve_ratio_bounds: Pair Uint256 Uint256,
  deadline_block: BNum
)
  (* check if current_block has passed the deadline block to process this transaction *)
  VerifyBlock deadline_block;
  (* check if pool contract for tokenA and tokenB exists *)
  VerifyPoolAddress tokenA tokenB pool;(* Order should not matter here *)

  r_a <- & pool.reserve0;
  r_b <- & pool.reserve1;
  v_r_a <- & pool.v_reserve0;
  v_r_b <- & pool.v_reserve1;

  e = 
    let r_a_ = builtin eq r_a zero_amount in 
    let r_b_ = builtin eq r_b zero_amount in 
    andb r_a_ r_b_;
  match e with 
  | True =>
    (* pool with no liquidity *)
    (* Transfer pairing of tokenA and tokenB to pool *)
    amountA = amountA_desired;
    amountB = amountB_desired;
    TransferFromZRC2 tokenA _sender pool amountA;
    TransferFromZRC2 tokenB _sender pool amountB
  | False =>
    (* pool with existing liquidity *)
    (* check how much tokenB is required to fulfil amountA_desired pairing *)
    Quote amountA_desired r_a r_b;
    amountB_optimal = quote amountA_desired r_a r_b;

    (* check if sufficient tokenB is provided to fulfil pairing *)
    is_sufficient_amountB = uint128_le amountB_optimal amountB_desired;
    match is_sufficient_amountB with
    | True =>
      (* sufficient tokenB is provided *)
      (* check if amount of tokenB to be deposited in pool is greater than or equal to the amountB_min user wants to deposit *)
      VerifyAmount amountB_optimal amountB_min;
      (* check if amount of tokenA to be deposited in pool is greater than or equal to the amountA_min user wants to deposit *)
      VerifyAmount amountA_desired amountA_min;

      (* Transfer pairing of tokenA and tokenB to pool *)
      amountA = amountA_desired;
      amountB = amountB_optimal;
      TransferFromZRC2 tokenA _sender pool amountA;
      TransferFromZRC2 tokenB _sender pool amountB
    | False =>
      (* insufficient tokenB is provided *)
      (* check how much tokenA is required to fulfil amountB_desired pairing *)
      Quote amountB_desired r_a r_b;
      amountA_optimal = quote amountB_desired r_b r_a;
      (* check if amount of tokenA provided is greater than or equal to the tokens required to fulfil the tokenB pairing *)
      VerifyAmount amountA_desired amountA_optimal;
      (* check if amount of tokenA to be deposited in pool is greater than or equal to the tokenA_min user wants to deposit *)
      VerifyAmount amountA_optimal amountA_min;
      (* check if amount of tokenB to be deposited in pool is greater than or equal to the tokenB_min user wants to deposit *)
      VerifyAmount amountB_desired amountB_min;

      (* Transfer pairing of tokenA and tokenB to pool *)
      amountA = amountA_optimal;
      amountB = amountB_desired;
      TransferFromZRC2 tokenA _sender pool amountA;
      TransferFromZRC2 tokenB _sender pool amountB
    end;

    amp <- & pool.amp_bps;
    is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;
    match is_amp_pool with 
    | False => 
    | True =>
    (* only for amp pool *)
      current_rate = 
        let v_r_a_u256 = grow v_r_a in
        let v_r_b_u256 = grow v_r_b in
        let a = builtin mul v_r_b_u256 q112_u256 in
        builtin div a v_r_a_u256;
      match v_reserve_ratio_bounds with
      | Pair l_bound u_bound =>
        is_not_out_of_bound_vreserve = 
          let l_b = uint256_ge current_rate l_bound in
          let u_b = uint256_le current_rate u_bound in
          andb l_b u_b;
        match is_not_out_of_bound_vreserve with 
        | True =>
        | False =>
          err = CodeOutOfBoundVReserve;
          ThrowError err
        end
      end
    end
  end;

  (* Calls Mint transition on Pool *)
  msg_to_pool = {_tag: "Mint"; _recipient: pool; _amount: zero_amount; to: _sender};
  msg = one_msg msg_to_pool;
  send msg
end

(* @solidity DMMRouter02.sol:
  verifyPoolAddress(token, weth, pool);
  (amountToken, amountETH) = _addLiquidity(token, weth, pool, amountTokenDesired, msg.value, amountTokenMin, amountETHMin, vReserveRatioBounds);
  token.safeTransferFrom(msg.sender, pool, amountToken);
  weth.deposit{value: amountETH}();
  weth.safeTransfer(pool, amountETH);
  liquidity = IDMMPool(pool).mint(to);
  // refund dust eth, if any
  if (msg.value > amountETH) {
      TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);
  }
*)
transition AddLiquidityZIL(
  token : ByStr20,
  pool: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field amp_bps : Uint128
  end,
  amount_token_desired: Uint128,
  amount_token_min: Uint128,
  amount_wZIL_min: Uint128,
  v_reserve_ratio_bounds: Pair Uint256 Uint256,
  deadline_block: BNum
)
  (* fetch wZIL addresses from mutable fields *)
  wZIL <- wZIL_address;

  (* check if current_block has passed the deadline block to process this transaction *)
  VerifyBlock deadline_block;
  (* check if pool contract for tokenA and tokenB exists *)
  VerifyPoolAddress token wZIL pool;(* Order should not matter here *)

  r_a <- & pool.reserve0;
  r_b <- & pool.reserve1;
  v_r_a <- & pool.v_reserve0;
  v_r_b <- & pool.v_reserve1;

  e = 
    let r_a_ = builtin eq r_a zero_amount in 
    let r_b_ = builtin eq r_b zero_amount in 
    andb r_a_ r_b_;
  match e with 
  | True =>
    (* pool with no liquidity,  *)
    amount_token = amount_token_desired;
    amount_wZIL = _amount;

    (* Send ZIL to wZIL contract and mint wZIL *)
    accept;
    WrapZIL amount_wZIL;

    (* Transfer pairing of wZIL and token to pool *)
    TransferFromZRC2 token _sender pool amount_token;
    TransferZRC2 wZIL pool amount_wZIL
  | False =>
    (* pool with existing liquidity *)
    (* check how much wZIL is required to fulfil amount_token_desired pairing *)
    Quote amount_token_desired r_a r_b;
    amount_wZIL_optimal = quote amount_token_desired r_a r_b;

    (* check if sufficient wZIL is provided to fulfil pairing *)
    is_sufficient_wZIL = uint128_le amount_wZIL_optimal _amount;
    match is_sufficient_wZIL with
    | True =>
      (* sufficient wZIL is provided *)
      (* check if amount of wZIL to be deposited in pool is greater than or equal to the min_wZIL user wants to deposit *)
      VerifyAmount amount_wZIL_optimal amount_wZIL_min;
      (* check if amount of token to be deposited in pool is greater than or equal to the min_token user wants to deposit *)
      VerifyAmount amount_token_desired amount_token_min;
      amount_token = amount_token_desired;
      amount_wZIL = amount_wZIL_optimal;

      (* Send ZIL to wZIL contract and mint wZIL *)
      accept;
      WrapZIL amount_wZIL;

      (* refund back remaining ZIL not used up in conversion to wZIL *)
      refund = builtin sub _amount amount_wZIL;
      Send refund _sender;

      (* Transfer pairing of wZIL and token to pool *)
      TransferFromZRC2 token _sender pool amount_token;
      TransferZRC2 wZIL pool amount_wZIL
    | False =>
      (* insufficient wZIL provided *)
      (* check how many tokens are required to fulfil wZIL pairing, based on insufficient wZIL provided *)
      Quote _amount r_a r_b;
      amount_token_optimal = quote _amount r_b r_a;
      (* check if amount of tokens provided is greater than or equal to the tokens required to fulfil the wZIL pairing *)
      VerifyAmount amount_token_desired amount_token_optimal;
      (* check if amount of wZIL to be deposited in pool is greater than or equal to the min_wZIL user wants to deposit *)
      VerifyAmount _amount amount_wZIL_min;
      (* check if amount of token to be deposited in pool is greater than or equal to the min_token user wants to deposit *)
      VerifyAmount amount_token_optimal amount_token_min;
      amount_token = amount_token_optimal;
      amount_wZIL = _amount;

      (* Send ZIL to wZIL contract and mint wZIL *)
      accept;
      WrapZIL amount_wZIL;
    
      (* transfers wZIL balance from this contract to user, that was obtained by using user's ZIL to mint wZIL *)
      TransferZRC2 wZIL _sender amount_wZIL;
      
      (* Transfer pairing of wZIL and token to pool *)
      TransferFromZRC2 token _sender pool amount_token;
      TransferZRC2 wZIL pool amount_wZIL
    end;

    amp <- & pool.amp_bps;
    is_amp_pool = let is_eq = builtin eq amp bps in negb is_eq;
    match is_amp_pool with 
    | False => 
    | True =>
    (* only for amp pool *)
      current_rate = 
        let v_r_a_u256 = grow v_r_a in
        let v_r_b_u256 = grow v_r_b in
        let a = builtin mul v_r_b_u256 q112_u256 in
        builtin div a v_r_a_u256;
      match v_reserve_ratio_bounds with
      | Pair l_bound u_bound =>
        is_not_out_of_bound_vreserve = 
          let l_b = uint256_ge current_rate l_bound in
          let u_b = uint256_le current_rate u_bound in
          andb l_b u_b;
        match is_not_out_of_bound_vreserve with 
        | True =>
        | False =>
          err = CodeOutOfBoundVReserve;
          ThrowError err
        end
      end
    end
  end;
  
  (* Calls Mint transition on Pool *)
  msg_to_pool = {_tag: "Mint"; _recipient: pool; _amount: zero_amount; to: _sender};
  msg = one_msg msg_to_pool;
  send msg
end

(* // **** REMOVE LIQUIDITY **** *)

(* @param: Order of tokens does not matter*)
(* @param: But ideally, tokenA < tokenB (ie tokenA == token0, tokenB == token1 on Pool) *)
(* @solidity DMMRouter02.sol:
  verifyPoolAddress(tokenA, tokenB, pool);
  IERC20(pool).safeTransferFrom(msg.sender, pool, liquidity); // send liquidity to pool
  (uint256 amount0, uint256 amount1) = IDMMPool(pool).burn(to);
  (IERC20 token0, ) = DMMLibrary.sortTokens(tokenA, tokenB);
  (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
  require(amountA >= amountAMin, "DMMRouter: INSUFFICIENT_A_AMOUNT");
  require(amountB >= amountBMin, "DMMRouter: INSUFFICIENT_B_AMOUNT");
*)
transition RemoveLiquidity(
  tokenA : ByStr20 with contract
    field balances: Map ByStr20 Uint128
  end,
  tokenB : ByStr20 with contract
    field balances: Map ByStr20 Uint128
  end,
  pool: ByStr20 with contract
    field total_supply: Uint128
  end,
  liquidity: Uint128,
  amountA_min: Uint128,
  amountB_min: Uint128,
  deadline_block: BNum
)
  VerifyBlock deadline_block;
  VerifyPoolAddress tokenA tokenB pool;

  (* fetch tokenA and tokenB balance held by pool *)
  m_b0 <- & tokenA.balances[pool];
  tokenA_balance = get_amount_or_zero m_b0;
  m_b1 <- & tokenB.balances[pool];
  tokenB_balance = get_amount_or_zero m_b1;

  (* fetch the total supply in the pool *)
  supply <- & pool.total_supply;

  (* calculate amount of tokenA and tokenB removed based on amount of liquidity provided *)
  tokenA_amount = frac liquidity tokenA_balance supply;
  tokenB_amount = frac liquidity tokenB_balance supply;

  (* check if amount of tokenA and tokenB removed matches min *)
  VerifyAmount tokenA_amount amountA_min;
  VerifyAmount tokenB_amount amountB_min;

  (* Sends LP tokens to Pool *)
  msg_to_pool_1 = {_tag: "TransferFrom"; _recipient: pool; _amount: zero_amount; 
                from: _sender; to: pool; amount: liquidity};

  (* Calls Burn transition on Pool, that transfers tokenA and tokenB back to _sender *)
  msg_to_pool_2 = {_tag: "Burn"; _recipient: pool; _amount: zero_amount};
  msgs = two_msgs msg_to_pool_1 msg_to_pool_2;
  send msgs
end

(* @solidity DMMRouter.sol:
  (amountToken, amountETH) = removeLiquidity(token, weth, pool, liquidity, amountTokenMin, amountETHMin, address(this), deadline);
  token.safeTransfer(to, amountToken);
  IWETH(weth).withdraw(amountETH);
  TransferHelper.safeTransferETH(to, amountETH); 
*)
transition RemoveLiquidityZIL(
  token: ByStr20 with contract
    field balances: Map ByStr20 Uint128
  end,
  pool: ByStr20 with contract
    field total_supply: Uint128
  end,
  liquidity: Uint128,
  amount_token_min: Uint128,
  amount_wZIL_min: Uint128,
  deadline_block: BNum
)
  (* fetch wZIL addresses from mutable fields *)
  wZIL <- wZIL_address;

  VerifyBlock deadline_block;
  VerifyPoolAddress token wZIL pool;

  (* fetch token and wZIL balance held by pool *)
  m_b0 <- & token.balances[pool];
  token_balance = get_amount_or_zero m_b0;
  m_b1 <- & wZIL.balances[pool];
  wZil_balance = get_amount_or_zero m_b1;

  (* fetch the total supply in the pool *)
  supply <- & pool.total_supply;

  (* calculate amount of tokens and wZIL removed based on amount of liquidity provided *)
  token_amount = frac liquidity token_balance supply;
  wZil_amount = frac liquidity wZil_balance supply;

  (* check if amount of tokens and wZIL removed matches min *)
  VerifyAmount token_amount amount_token_min;
  VerifyAmount wZil_amount amount_wZIL_min;

  (* Sends LP tokens to Pool *)
  msg_to_pool_1 = {_tag: "TransferFrom"; _recipient: pool; _amount: zero_amount; 
                from: _sender; to: pool; amount: liquidity};

  (* Calls Burn transition on Pool, that transfers token and wZIL back to _sender *)
  msg_to_pool_2 = {_tag: "Burn"; _recipient: pool; _amount: zero_amount};

  msgs = two_msgs msg_to_pool_1 msg_to_pool_2;
  send msgs;

  (* transfer wZIL to this contract *)
  TransferFromZRC2 wZIL _sender _this_address wZil_amount;

  (* call Burn on wZIL to convert back to ZIL, callback will handle transfer of ZIL to _sender *)
  UnwrapZIL wZil_amount
end

(*** SWAP ***)

(* @param path: token_in token_out *)
(* @solidity DMMRouter02.sol:
  verifyPoolsPathSwap(poolsPath, path);
  amounts = DMMLibrary.getAmountsOut(amountIn, poolsPath, path);
  require(amounts[amounts.length - 1] >= amountOutMin, "DMMRouter: INSUFFICIENT_OUTPUT_AMOUNT");
  IERC20(path[0]).safeTransferFrom(msg.sender, poolsPath[0], amounts[0]);
  _swap(amounts, poolsPath, path, to);
*)
transition SwapExactTokensForTokensOnce(
  amount_in: Uint128,
  amount_out_min: Uint128,
  pool: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_out == 0 *)
  amount_out <- amt_out;
  is_valid_amount_out = builtin eq amount_out zero_amount;
  match is_valid_amount_out with
  | True => | False =>
    amt_out := zero_amount
  end;

  GetAmountOut amount_in pool path deadline_block;
  final_amount_out <- amt_out;
  is_valid_final_amount_out = uint128_gt final_amount_out amount_out_min;
  match is_valid_final_amount_out with 
  | True => | False => 
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool before swap *)
  TransferFromZRC2ToPool pool path amount_in;
  
  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool path final_amount_out _sender;
  amt_out := zero_amount (* Reassign back to 0 *)
end

(* @dev: amount_in -> pool1 -> intermediate_amount_out *)
(* @dev: intermediate_amount_out -> pool2 -> final_amount_out *)
(* @param path: token_in token_out *)
transition SwapExactTokensForTokensTwice(
  amount_in: Uint128,
  amount_out_min: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_out == 0 *)
  amount_out <- amt_out;
  is_valid_amount_out = builtin eq amount_out zero_amount;
  match is_valid_amount_out with
  | True => | False =>
    amt_out := zero_amount
  end;

  GetAmountOut amount_in pool1 path1 deadline_block;
  intermediate_amount_out <- amt_out;
  VerifyValidAmountIn intermediate_amount_out;

  GetAmountOut intermediate_amount_out pool2 path2 deadline_block;
  final_amount_out <- amt_out;
  is_valid_final_amount_out = uint128_gt final_amount_out amount_out_min;
  match is_valid_final_amount_out with 
  | True => | False => 
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;
  
  (* pre-transfer ZRC2 tokens to pool1 before swap *)
  TransferFromZRC2ToPool pool1 path1 amount_in;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 intermediate_amount_out pool2;
  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool2 path2 final_amount_out _sender;

  amt_out := zero_amount (* Reassign back to 0 *)
end

(* @dev: amount_in -> pool1 -> first_intermediate_amount_out *)
(* @dev: first_intermediate_amount_out -> pool2 -> second_intermediate_amount_out *)
(* @dev: second_intermediate_amount_out -> pool3 -> final_amount_out *)
(* @param path: token_in token_out *)
transition SwapExactTokensForTokensThrice(
  amount_in: Uint128,
  amount_out_min: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool3: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  path3: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_out == 0 *)
  amount_out <- amt_out;
  is_valid_amount_out = builtin eq amount_out zero_amount;
  match is_valid_amount_out with
  | True => | False =>
    amt_out := zero_amount
  end;

  GetAmountOut amount_in pool1 path1 deadline_block;
  first_intermediate_amount_out <- amt_out;
  VerifyValidAmountIn first_intermediate_amount_out;

  GetAmountOut first_intermediate_amount_out pool2 path2 deadline_block;
  second_intermediate_amount_out <- amt_out;
  VerifyValidAmountIn second_intermediate_amount_out;

  GetAmountOut second_intermediate_amount_out pool3 path3 deadline_block;
  final_amount_out <- amt_out;
  is_valid_final_amount_out = uint128_gt final_amount_out amount_out_min;
  match is_valid_final_amount_out with 
  | True => | False => 
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool1 before swap *)
  TransferFromZRC2ToPool pool1 path1 amount_in;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 first_intermediate_amount_out pool2;
  (* swap out ZRC2 tokens straight into pool3 *)
  SwapZRC2Once pool2 path2 second_intermediate_amount_out pool3;
  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool3 path3 final_amount_out _sender;

  amt_out := zero_amount (* Reassign back to 0 *)
end

(* @dev: init_amt_in -> pool -> amount_out *)
(* @param path: token_in token_out *)
(* @solidity DMMRouter02.sol:
  verifyPoolsPathSwap(poolsPath, path);
  amounts = DMMLibrary.getAmountsIn(amountOut, poolsPath, path);
  require(amounts[0] <= amountInMax, "DMMRouter: EXCESSIVE_INPUT_AMOUNT");
  path[0].safeTransferFrom(msg.sender, poolsPath[0], amounts[0]);
  _swap(amounts, poolsPath, path, to);
*)
transition SwapTokensForExactTokensOnce(
  amount_out: Uint128,
  amount_in_max: Uint128,
  pool: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_in == 0 *)
  amount_in <- amt_in;
  is_valid_amt_in = builtin eq amount_in zero_amount;
  match is_valid_amt_in with 
  | True => | False =>
    amt_in := zero_amount
  end;

  GetAmountIn amount_out pool path deadline_block;
  init_amt_in <- amt_in;
  VerifyValidAmountIn init_amt_in;

  is_valid_amount_in = uint128_le init_amt_in amount_in_max;
  match is_valid_amount_in with 
  | True => | False =>
    err = CodeExcessiveInputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool before swap *)
  TransferFromZRC2ToPool pool path init_amt_in;

  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool path amount_out _sender;
  amt_in := zero_amount (* Reassign back to 0 *)
end

(* @dev: init_amt_in -> pool1 -> intermediate_amt_in *)
(* @dev: intermediate_amt_in -> pool2 -> amount_out *)
(* @param path: token_in token_out *)
transition SwapTokensForExactTokensTwice(
  amount_out: Uint128,
  amount_in_max: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_in == 0 *)
  amount_in <- amt_in;
  is_valid_amt_in = builtin eq amount_in zero_amount;
  match is_valid_amt_in with 
  | True => | False =>
    amt_in := zero_amount
  end;

  GetAmountIn amount_out pool2 path2 deadline_block;
  intermediate_amt_in <- amt_in;
  VerifyValidAmountIn intermediate_amt_in;

  GetAmountIn intermediate_amt_in pool1 path1 deadline_block;
  init_amt_in <- amt_in;
  VerifyValidAmountIn init_amt_in;

  is_valid_amount_in = uint128_le init_amt_in amount_in_max;
  match is_valid_amount_in with 
  | True => | False =>
    err = CodeExcessiveInputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool1 before swap *)
  TransferFromZRC2ToPool pool1 path1 init_amt_in;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 intermediate_amt_in pool2;
  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool2 path2 amount_out _sender;

  amt_in := zero_amount (* Reassign back to 0 *)
end

(* @dev: init_amount_in -> pool1 -> first_intermediate_amount_in *)
(* @dev: first_intermediate_amount_in -> pool2 -> second_intermediate_amount_in *)
(* @dev: second_intermediate_amount_in -> pool3 -> amount_out *)
(* @param path: token_in token_out *)
transition SwapTokensForExactTokensThrice(
  amount_out: Uint128,
  amount_in_max: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool3: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  path3: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_in == 0 *)
  amount_in <- amt_in;
  is_valid_amt_in = builtin eq amount_in zero_amount;
  match is_valid_amt_in with 
  | True => | False =>
    amt_in := zero_amount
  end;

  GetAmountIn amount_out pool3 path3 deadline_block;
  second_intermediate_amt_in <- amt_in;
  VerifyValidAmountIn second_intermediate_amt_in;

  GetAmountIn second_intermediate_amt_in pool2 path2 deadline_block;
  first_intermediate_amt_in <- amt_in;
  VerifyValidAmountIn first_intermediate_amt_in;

  GetAmountIn first_intermediate_amt_in pool1 path1 deadline_block;
  init_amt_in <- amt_in;
  VerifyValidAmountIn init_amt_in;

  is_valid_amount_in = uint128_le init_amt_in amount_in_max;
  match is_valid_amount_in with 
  | True => | False =>
    err = CodeExcessiveInputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool1 before swap *)
  TransferFromZRC2ToPool pool1 path1 init_amt_in;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 first_intermediate_amt_in pool2;
  (* swap out ZRC2 tokens straight into pool3 *)
  SwapZRC2Once pool2 path2 second_intermediate_amt_in pool3;
  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool3 path3 amount_out _sender;

  amt_in := zero_amount (* Reassign back to 0 *)
end

(* @solidity DMMRouter02.sol:
  require(path[0] == weth, "DMMRouter: INVALID_PATH");
  verifyPoolsPathSwap(poolsPath, path);
  amounts = DMMLibrary.getAmountsOut(msg.value, poolsPath, path);
  require(amounts[amounts.length - 1] >= amountOutMin, "DMMRouter: INSUFFICIENT_OUTPUT_AMOUNT");
  IWETH(weth).deposit{value: amounts[0]}();
  weth.safeTransfer(poolsPath[0], amounts[0]);
  _swap(amounts, poolsPath, path, to);
*)
transition SwapExactZILForTokensOnce(
  amount_out_min: Uint128,
  pool: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_out == 0 *)
  amount_out <- amt_out;
  is_valid_amount_out = builtin eq amount_out zero_amount;
  match is_valid_amount_out with
  | True => | False =>
    amt_out := zero_amount
  end;

  GetAmountOut _amount pool path deadline_block;
  final_amount_out <- amt_out;
  is_valid_final_amount_out = uint128_gt final_amount_out amount_out_min;
  match is_valid_final_amount_out with 
  | True => | False => 
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  (* accept ZIL *)
  accept;

  (* convert ZIL to wZIL *)
  wZIL = get_from_address path;
  VerifyWZILAddress wZIL;
  WrapZIL _amount;

  (* pre-transfers wZIL balance from this contract straight to pool before swap *)
  TransferZRC2ToPool pool path _amount;

  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool path final_amount_out _sender;

  amt_out := zero_amount (* Reassign back to 0 *)
end

transition SwapExactZILForTokensTwice(
  amount_out_min: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_out == 0 *)
  amount_out <- amt_out;
  is_valid_amount_out = builtin eq amount_out zero_amount;
  match is_valid_amount_out with
  | True => | False =>
    amt_out := zero_amount
  end;

  GetAmountOut _amount pool1 path1 deadline_block;
  intermediate_amount_out <- amt_out;
  VerifyValidAmountIn intermediate_amount_out;

  GetAmountOut intermediate_amount_out pool2 path2 deadline_block;
  final_amount_out <- amt_out;
  is_valid_final_amount_out = uint128_gt final_amount_out amount_out_min;
  match is_valid_final_amount_out with 
  | True => | False => 
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  (* accept ZIL *)
  accept;

  (* convert ZIL to wZIL *)
  wZIL = get_from_address path1;
  VerifyWZILAddress wZIL;
  WrapZIL _amount;

  (* pre-transfers wZIL balance from this contract straight to pool1 before swap *)
  TransferZRC2ToPool pool1 path1 _amount;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 intermediate_amount_out pool2;
  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool2 path2 final_amount_out _sender;

  amt_out := zero_amount (* Reassign back to 0 *)
end

transition SwapExactZILForTokensThrice(
  amount_out_min: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool3: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  path3: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_out == 0 *)
  amount_out <- amt_out;
  is_valid_amount_out = builtin eq amount_out zero_amount;
  match is_valid_amount_out with
  | True => | False =>
    amt_out := zero_amount
  end;

  GetAmountOut _amount pool1 path1 deadline_block;
  first_intermediate_amount_out <- amt_out;
  VerifyValidAmountIn first_intermediate_amount_out;

  GetAmountOut first_intermediate_amount_out pool2 path2 deadline_block;
  second_intermediate_amount_out <- amt_out;
  VerifyValidAmountIn second_intermediate_amount_out;

  GetAmountOut second_intermediate_amount_out pool3 path3 deadline_block;
  final_amount_out <- amt_out;
  is_valid_final_amount_out = uint128_gt final_amount_out amount_out_min;
  match is_valid_final_amount_out with 
  | True => | False => 
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  (* accept ZIL *)
  accept;

  (* convert ZIL to wZIL *)
  wZIL = get_from_address path1;
  VerifyWZILAddress wZIL;
  WrapZIL _amount;

  (* pre-transfers wZIL balance from this contract straight to pool1 before swap *)
  TransferZRC2ToPool pool1 path1 _amount;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 first_intermediate_amount_out pool2;
  (* swap out ZRC2 tokens straight into pool3 *)
  SwapZRC2Once pool2 path2 second_intermediate_amount_out pool3;
  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool3 path3 final_amount_out _sender;

  amt_out := zero_amount (* Reassign back to 0 *)
end

(* @dev: Hits the max depth error *)
transition SwapExactZILForTokensQuad(
  amount_out_min: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool3: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool4: ByStr20 with contract
  field reserve0 : Uint128,
  field reserve1 : Uint128,
  field amp_bps : Uint128,
  field v_reserve0 : Uint128,
  field v_reserve1 : Uint128,
  field short_ema : Uint256,
  field long_ema : Uint256,
  field current_block_volume : Uint128,
  field last_trade_block : BNum
end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  path3: Pair ByStr20 ByStr20,
  path4: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_out == 0 *)
  amount_out <- amt_out;
  is_valid_amount_out = builtin eq amount_out zero_amount;
  match is_valid_amount_out with
  | True => | False =>
    amt_out := zero_amount
  end;

  GetAmountOut _amount pool1 path1 deadline_block;
  first_intermediate_amount_out <- amt_out;
  VerifyValidAmountIn first_intermediate_amount_out;

  GetAmountOut first_intermediate_amount_out pool2 path2 deadline_block;
  second_intermediate_amount_out <- amt_out;
  VerifyValidAmountIn second_intermediate_amount_out;

  GetAmountOut second_intermediate_amount_out pool3 path3 deadline_block;
  third_intermediate_amount_out <- amt_out;
  VerifyValidAmountIn third_intermediate_amount_out;

  GetAmountOut third_intermediate_amount_out pool4 path4 deadline_block;
  final_amount_out <- amt_out;
  is_valid_final_amount_out = uint128_gt final_amount_out amount_out_min;
  match is_valid_final_amount_out with 
  | True => | False => 
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  (* accept ZIL *)
  accept;

  (* convert ZIL to wZIL *)
  wZIL = get_from_address path1;
  VerifyWZILAddress wZIL;
  WrapZIL _amount;

  (* pre-transfers wZIL balance from this contract straight to pool1 before swap *)
  TransferZRC2ToPool pool1 path1 _amount;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 first_intermediate_amount_out pool2;
  (* swap out ZRC2 tokens straight into pool3 *)
  SwapZRC2Once pool2 path2 second_intermediate_amount_out pool3;
  (* swap out ZRC2 tokens straight into pool4 *)
  SwapZRC2Once pool3 path3 third_intermediate_amount_out pool4;
  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool4 path4 final_amount_out _sender;

  amt_out := zero_amount (* Reassign back to 0 *)
end

(* @solidity DMMRouter02.sol:
  require(path[path.length - 1] == weth, "DMMRouter: INVALID_PATH");
  verifyPoolsPathSwap(poolsPath, path);
  amounts = DMMLibrary.getAmountsIn(amountOut, poolsPath, path);
  require(amounts[0] <= amountInMax, "DMMRouter: EXCESSIVE_INPUT_AMOUNT");
  path[0].safeTransferFrom(msg.sender, poolsPath[0], amounts[0]);
  _swap(amounts, poolsPath, path, address(this));
  IWETH(weth).withdraw(amounts[amounts.length - 1]);
  TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
*)
transition SwapTokensForExactZILOnce(
  amount_out: Uint128,
  amount_in_max: Uint128,
  pool: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_in == 0 *)
  amount_in <- amt_in;
  is_valid_amt_in = builtin eq amount_in zero_amount;
  match is_valid_amt_in with 
  | True => | False =>
    amt_in := zero_amount
  end;

  GetAmountIn amount_out pool path deadline_block;
  init_amt_in <- amt_in;
  VerifyValidAmountIn init_amt_in;

  is_valid_amount_in = uint128_le init_amt_in amount_in_max;
  match is_valid_amount_in with 
  | True => | False =>
    err = CodeExcessiveInputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool before swap *)
  TransferFromZRC2ToPool pool path init_amt_in;

  (* swap out wZIL tokens straight to this contract *)
  SwapZRC2Once pool path amount_out _this_address;

  (* call Burn on wZIL to convert back to ZIL, callback will handle transfer of ZIL to user *)
  wZIL = get_to_address path;
  VerifyWZILAddress wZIL;
  UnwrapZIL amount_out;

  amt_in := zero_amount (* Reassign back to 0 *)
end

transition SwapTokensForExactZILTwice(
  amount_out: Uint128,
  amount_in_max: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_in == 0 *)
  amount_in <- amt_in;
  is_valid_amt_in = builtin eq amount_in zero_amount;
  match is_valid_amt_in with 
  | True => | False =>
    amt_in := zero_amount
  end;

  GetAmountIn amount_out pool2 path2 deadline_block;
  intermediate_amt_in <- amt_in;
  VerifyValidAmountIn intermediate_amt_in;
  
  GetAmountIn intermediate_amt_in pool1 path1 deadline_block;
  init_amt_in <- amt_in;
  VerifyValidAmountIn init_amt_in;

  is_valid_amount_in = uint128_le init_amt_in amount_in_max;
  match is_valid_amount_in with 
  | True => | False =>
    err = CodeExcessiveInputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool1 before swap *)
  TransferFromZRC2ToPool pool1 path1 init_amt_in;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 intermediate_amt_in pool2;
  (* swap out wZIL tokens straight to this contract *)
  SwapZRC2Once pool2 path2 amount_out _this_address;

  (* call Burn on wZIL to convert back to ZIL, callback will handle transfer of ZIL to user *)
  wZIL = get_to_address path2;
  VerifyWZILAddress wZIL;
  UnwrapZIL amount_out;

  amt_in := zero_amount (* Reassign back to 0 *)
end

transition SwapTokensForExactZILThrice(
  amount_out: Uint128,
  amount_in_max: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool3: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  path3: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_in == 0 *)
  amount_in <- amt_in;
  is_valid_amt_in = builtin eq amount_in zero_amount;
  match is_valid_amt_in with 
  | True => | False =>
    amt_in := zero_amount
  end;

  GetAmountIn amount_out pool3 path3 deadline_block;
  second_intermediate_amt_in <- amt_in;
  VerifyValidAmountIn second_intermediate_amt_in;

  GetAmountIn second_intermediate_amt_in pool2 path2 deadline_block;
  first_intermediate_amt_in <- amt_in;
  VerifyValidAmountIn first_intermediate_amt_in;
  
  GetAmountIn first_intermediate_amt_in pool1 path1 deadline_block;
  init_amt_in <- amt_in;
  VerifyValidAmountIn init_amt_in;

  is_valid_amount_in = uint128_le init_amt_in amount_in_max;
  match is_valid_amount_in with 
  | True => | False =>
    err = CodeExcessiveInputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool1 before swap *)
  TransferFromZRC2ToPool pool1 path1 init_amt_in;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 first_intermediate_amt_in pool2;
  (* swap out ZRC2 tokens straight into pool3 *)
  SwapZRC2Once pool2 path2 second_intermediate_amt_in pool3;
  (* swap out wZIL tokens straight to this contract *)
  SwapZRC2Once pool3 path3 amount_out _this_address;

  (* call Burn on wZIL to convert back to ZIL, callback will handle transfer of ZIL to user *)
  wZIL = get_to_address path3;
  VerifyWZILAddress wZIL;
  UnwrapZIL amount_out;

  amt_in := zero_amount (* Reassign back to 0 *)
end

(* @solidity DMMRouter02.sol:
  require(path[path.length - 1] == weth, "DMMRouter: INVALID_PATH");
  verifyPoolsPathSwap(poolsPath, path);
  amounts = DMMLibrary.getAmountsOut(amountIn, poolsPath, path);
  require(amounts[amounts.length - 1] >= amountOutMin,"DMMRouter: INSUFFICIENT_OUTPUT_AMOUNT");
  path[0].safeTransferFrom(msg.sender, poolsPath[0], amounts[0]);
  _swap(amounts, poolsPath, path, address(this));
  IWETH(weth).withdraw(amounts[amounts.length - 1]);
  TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
*)
transition SwapExactTokensForZILOnce(
  amount_in: Uint128,
  amount_out_min: Uint128,
  pool: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_out == 0 *)
  amount_out <- amt_out;
  is_valid_amount_out = builtin eq amount_out zero_amount;
  match is_valid_amount_out with
  | True => | False =>
    amt_out := zero_amount
  end;

  GetAmountOut amount_in pool path deadline_block;
  final_amount_out <- amt_out;
  is_valid_final_amount_out = uint128_gt final_amount_out amount_out_min;
  match is_valid_final_amount_out with 
  | True => | False => 
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool before swap *)
  TransferFromZRC2ToPool pool path amount_in;

  (* swap out wZIL tokens straight to this contract *)
  SwapZRC2Once pool path final_amount_out _this_address;

  (* call Burn on wZIL to convert back to ZIL, callback will handle transfer of ZIL to user *)
  wZIL = get_to_address path;
  VerifyWZILAddress wZIL;
  UnwrapZIL final_amount_out;

  amt_out := zero_amount (* Reassign back to 0 *)
end

transition SwapExactTokensForZILTwice(
  amount_in: Uint128,
  amount_out_min: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_out == 0 *)
  amount_out <- amt_out;
  is_valid_amount_out = builtin eq amount_out zero_amount;
  match is_valid_amount_out with
  | True => | False =>
    amt_out := zero_amount
  end;

  GetAmountOut amount_in pool1 path1 deadline_block;
  intermediate_amount_out <- amt_out;
  VerifyValidAmountIn intermediate_amount_out;

  GetAmountOut intermediate_amount_out pool2 path2 deadline_block;
  final_amount_out <- amt_out;
  is_valid_final_amount_out = uint128_gt final_amount_out amount_out_min;
  match is_valid_final_amount_out with 
  | True => | False => 
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool1 before swap *)
  TransferFromZRC2ToPool pool1 path1 amount_in;

  (* swap out wZIL tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 intermediate_amount_out pool2;
  (* swap out wZIL tokens straight to this contract *)
  SwapZRC2Once pool2 path2 final_amount_out _this_address;

  (* call Burn on wZIL to convert back to ZIL, callback will handle transfer of ZIL to user *)
  wZIL = get_to_address path2;
  VerifyWZILAddress wZIL;
  UnwrapZIL final_amount_out;

  amt_out := zero_amount (* Reassign back to 0 *)
end

transition SwapExactTokensForZILThrice(
  amount_in: Uint128,
  amount_out_min: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool3: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  path3: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_out == 0 *)
  amount_out <- amt_out;
  is_valid_amount_out = builtin eq amount_out zero_amount;
  match is_valid_amount_out with
  | True => | False =>
    amt_out := zero_amount
  end;

  GetAmountOut amount_in pool1 path1 deadline_block;
  first_intermediate_amount_out <- amt_out;
  VerifyValidAmountIn first_intermediate_amount_out;

  GetAmountOut first_intermediate_amount_out pool2 path2 deadline_block;
  second_intermediate_amount_out <- amt_out;
  VerifyValidAmountIn second_intermediate_amount_out;

  GetAmountOut second_intermediate_amount_out pool3 path3 deadline_block;
  final_amount_out <- amt_out;
  is_valid_final_amount_out = uint128_gt final_amount_out amount_out_min;
  match is_valid_final_amount_out with 
  | True => | False => 
    err = CodeInsufficientOutputAmt;
    ThrowError err
  end;

  (* pre-transfer ZRC2 tokens to pool1 before swap *)
  TransferFromZRC2ToPool pool1 path1 amount_in;

  (* swap out wZIL tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 first_intermediate_amount_out pool2;
  (* swap out wZIL tokens straight into pool3 *)
  SwapZRC2Once pool2 path2 second_intermediate_amount_out pool3;
  (* swap out wZIL tokens straight to this contract *)
  SwapZRC2Once pool3 path3 final_amount_out _this_address;

  (* call Burn on wZIL to convert back to ZIL, callback will handle transfer of ZIL to user *)
  wZIL = get_to_address path3;
  VerifyWZILAddress wZIL;
  UnwrapZIL final_amount_out;

  amt_out := zero_amount (* Reassign back to 0 *)
end

(* @solidity:
  require(path[0] == weth, "DMMRouter: INVALID_PATH");
  verifyPoolsPathSwap(poolsPath, path);
  amounts = DMMLibrary.getAmountsIn(amountOut, poolsPath, path);
  require(amounts[0] <= msg.value, "DMMRouter: EXCESSIVE_INPUT_AMOUNT");
  IWETH(weth).deposit{value: amounts[0]}();
  weth.safeTransfer(poolsPath[0], amounts[0]);
  _swap(amounts, poolsPath, path, to);
  // refund dust eth, if any
  if (msg.value > amounts[0]) { TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]); }
*)
transition SwapZILForExactTokensOnce(
  amount_out: Uint128,
  pool: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_in == 0 *)
  amount_in <- amt_in;
  is_valid_amt_in = builtin eq amount_in zero_amount;
  match is_valid_amt_in with 
  | True => | False =>
    amt_in := zero_amount
  end;

  GetAmountIn amount_out pool path deadline_block;
  init_amt_in <- amt_in;
  VerifyValidAmountIn init_amt_in;

  is_valid_amount_in = uint128_le init_amt_in _amount;
  match is_valid_amount_in with 
  | True => | False =>
    err = CodeExcessiveInputAmt;
    ThrowError err
  end;

  (* accept ZIL *)
  accept;

  (* convert ZIL to wZIL *)
  wZIL = get_from_address path;
  VerifyWZILAddress wZIL;
  WrapZIL init_amt_in;

  (* refund back remaining ZIL not used up in conversion to wZIL *)
  refund = builtin sub _amount init_amt_in;
  Send refund _sender;

  (* pre-transfers wZIL balance from this contract straight to pool before swap *)
  TransferZRC2ToPool pool path init_amt_in;

  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool path amount_out _sender;

  amt_in := zero_amount (* Reassign back to 0 *)
end

transition SwapZILForExactTokensTwice(
  amount_out: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_in == 0 *)
  amount_in <- amt_in;
  is_valid_amt_in = builtin eq amount_in zero_amount;
  match is_valid_amt_in with 
  | True => | False =>
    amt_in := zero_amount
  end;

  GetAmountIn amount_out pool2 path2 deadline_block;
  intermediate_amt_in <- amt_in;
  VerifyValidAmountIn intermediate_amt_in;

  GetAmountIn intermediate_amt_in pool1 path1 deadline_block;
  init_amt_in <- amt_in;
  VerifyValidAmountIn init_amt_in;

  is_valid_amount_in = uint128_le init_amt_in _amount;
  match is_valid_amount_in with 
  | True => | False =>
    err = CodeExcessiveInputAmt;
    ThrowError err
  end;

  (* accept ZIL *)
  accept;

  (* convert ZIL to wZIL *)
  wZIL = get_from_address path1;
  VerifyWZILAddress wZIL;
  WrapZIL init_amt_in;

  (* refund back remaining ZIL not used up in conversion to wZIL *)
  refund = builtin sub _amount init_amt_in;
  Send refund _sender;

  (* pre-transfers wZIL balance from this contract straight to pool1 before swap *)
  TransferZRC2ToPool pool1 path1 init_amt_in;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 intermediate_amt_in pool2;
  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool2 path2 amount_out _sender;

  amt_in := zero_amount (* Reassign back to 0 *)
end

transition SwapZILForExactTokensThrice(
  amount_out: Uint128,
  pool1: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool2: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  pool3: ByStr20 with contract
    field reserve0 : Uint128,
    field reserve1 : Uint128,
    field amp_bps : Uint128,
    field v_reserve0 : Uint128,
    field v_reserve1 : Uint128,
    field short_ema : Uint256,
    field long_ema : Uint256,
    field current_block_volume : Uint128,
    field last_trade_block : BNum
  end,
  path1: Pair ByStr20 ByStr20,
  path2: Pair ByStr20 ByStr20,
  path3: Pair ByStr20 ByStr20,
  deadline_block: BNum
)
  (* Checks if amt_in == 0 *)
  amount_in <- amt_in;
  is_valid_amt_in = builtin eq amount_in zero_amount;
  match is_valid_amt_in with 
  | True => | False =>
    amt_in := zero_amount
  end;

  GetAmountIn amount_out pool3 path3 deadline_block;
  second_intermediate_amt_in <- amt_in;
  VerifyValidAmountIn second_intermediate_amt_in;
  
  GetAmountIn second_intermediate_amt_in pool2 path2 deadline_block;
  first_intermediate_amt_in <- amt_in;
  VerifyValidAmountIn first_intermediate_amt_in;

  GetAmountIn first_intermediate_amt_in pool1 path1 deadline_block;
  init_amt_in <- amt_in;
  VerifyValidAmountIn init_amt_in;

  is_valid_amount_in = uint128_le init_amt_in _amount;
  match is_valid_amount_in with 
  | True => | False =>
    err = CodeExcessiveInputAmt;
    ThrowError err
  end;

  (* accept ZIL *)
  accept;

  (* convert ZIL to wZIL *)
  wZIL = get_from_address path1;
  VerifyWZILAddress wZIL;
  WrapZIL init_amt_in;

  (* refund back remaining ZIL not used up in conversion to wZIL *)
  refund = builtin sub _amount init_amt_in;
  Send refund _sender;

  (* pre-transfers wZIL balance from this contract straight to pool1 before swap *)
  TransferZRC2ToPool pool1 path1 init_amt_in;

  (* swap out ZRC2 tokens straight into pool2 *)
  SwapZRC2Once pool1 path1 first_intermediate_amt_in pool2;
  (* swap out ZRC2 tokens straight into pool3  *)
  SwapZRC2Once pool2 path2 second_intermediate_amt_in pool3;
  (* swap out ZRC2 tokens straight back to _sender *)
  SwapZRC2Once pool3 path3 amount_out _sender;

  amt_in := zero_amount (* Reassign back to 0 *)
end

(*************************************)
(*             Callbacks             *)
(*************************************)

(* @dev: Handle callback when sending ZRC-2 tokens to the recipient using TransferFrom transition *)
transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end

(* @dev: Handle callback when sending ZRC-2 tokens to the recipient using Transfer transition *)
transition TransferSuccessCallBack(sender: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end

(* @dev: Handle callback when sending ZRC-2 tokens to the recipient using Transfer transition *)
transition RecipientAcceptTransfer(sender: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end

(* @dev: Handle callback when sending ZRC-2 tokens to the recipient using TransferFrom transition *)
transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end

(* @dev: Handle callback when minting wZIL tokens to the contract *)
transition RecipientAcceptMint(minter: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end

(* @dev: Handle callback when minting wZIL tokens to the contract *)
transition MintSuccessCallBack(minter: ByStr20, recipient: ByStr20, amount: Uint128)
(* no-op *)
end

(* @dev: Handling accepting of ZIL from wZIL contract *)
transition AddFunds()
  (* validate that _sender is wZIL *)
  VerifyWZILAddress _sender;

  (* accept ZIL from wZIL contract *)
  accept;
  amount <- _balance;

  (* Transfer ZIL to _origin *)
  msg_to_origin = {
    _tag: "AddFunds";
    _recipient: _origin;
    _amount: amount
  };

  msg = one_msg msg_to_origin;
  send msg
end
